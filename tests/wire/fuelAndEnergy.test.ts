// This file was auto-generated by Fern from our API Definition.

import * as Samsara from "../../src/api/index";
import { SamsaraClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("FuelAndEnergyClient", () => {
    test("getDriverEfficiencyByDrivers (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    difficultyScore: { overallScore: "4", topographyScore: "5", vehicleWeightScore: "4" },
                    driverId: "driver_001",
                    percentageData: {
                        anticipationPercentage: 9.5,
                        coastingPercentage: 45.6,
                        cruiseControlPercentage: 45.6,
                        greenBandPercentage: 78.9,
                        highGradeRoadDrivingPercentage: 15.3,
                        highTorquePercentage: 23.4,
                        idlingPercentage: 12.8,
                        overSpeedPercentage: 5.6,
                        wearFreeBrakePercentage: 88.2,
                    },
                    rawData: {
                        anticipationBrakeEventCount: 17,
                        averageVehicleWeightKg: 14500,
                        coastingDurationMs: 1900800,
                        cruiseControlDurationMs: 3283200,
                        driveTimeDurationMs: 7200000,
                        engineOnDurationMs: 7500000,
                        greenBandDurationMs: 5683200,
                        highGradeRoadDrivingDurationMs: 1108800,
                        highTorqueDurationMs: 1684800,
                        idlingDurationMs: 921600,
                        overSpeedDurationMs: 403200,
                        totalBrakeDurationMs: 1022400,
                        totalBrakeEventCount: 85,
                        wearFreeBrakeDurationMs: 6340800,
                    },
                    scoreData: {
                        anticipationScore: "C",
                        coastingScore: "C",
                        cruiseControlScore: "B",
                        greenBandScore: "A",
                        highTorqueScore: "A",
                        idlingScore: "B",
                        overSpeedScore: "B",
                        overallScore: "A",
                        wearFreeBrakeScore: "A",
                    },
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
            startTime: "startTime",
            endTime: "endTime",
        });
        expect(response).toEqual({
            data: [
                {
                    difficultyScore: {
                        overallScore: "4",
                        topographyScore: "5",
                        vehicleWeightScore: "4",
                    },
                    driverId: "driver_001",
                    percentageData: {
                        anticipationPercentage: 9.5,
                        coastingPercentage: 45.6,
                        cruiseControlPercentage: 45.6,
                        greenBandPercentage: 78.9,
                        highGradeRoadDrivingPercentage: 15.3,
                        highTorquePercentage: 23.4,
                        idlingPercentage: 12.8,
                        overSpeedPercentage: 5.6,
                        wearFreeBrakePercentage: 88.2,
                    },
                    rawData: {
                        anticipationBrakeEventCount: 17,
                        averageVehicleWeightKg: 14500,
                        coastingDurationMs: 1900800,
                        cruiseControlDurationMs: 3283200,
                        driveTimeDurationMs: 7200000,
                        engineOnDurationMs: 7500000,
                        greenBandDurationMs: 5683200,
                        highGradeRoadDrivingDurationMs: 1108800,
                        highTorqueDurationMs: 1684800,
                        idlingDurationMs: 921600,
                        overSpeedDurationMs: 403200,
                        totalBrakeDurationMs: 1022400,
                        totalBrakeEventCount: 85,
                        wearFreeBrakeDurationMs: 6340800,
                    },
                    scoreData: {
                        anticipationScore: "C",
                        coastingScore: "C",
                        cruiseControlScore: "B",
                        greenBandScore: "A",
                        highTorqueScore: "A",
                        idlingScore: "B",
                        overSpeedScore: "B",
                        overallScore: "A",
                        wearFreeBrakeScore: "A",
                    },
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getDriverEfficiencyByDrivers (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getDriverEfficiencyByDrivers (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getDriverEfficiencyByDrivers (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getDriverEfficiencyByDrivers (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getDriverEfficiencyByDrivers (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getDriverEfficiencyByDrivers (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getDriverEfficiencyByDrivers (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getDriverEfficiencyByDrivers (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getDriverEfficiencyByDrivers (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/drivers")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByDrivers({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getDriverEfficiencyByVehicles (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    difficultyScore: { overallScore: "4", topographyScore: "5", vehicleWeightScore: "4" },
                    percentageData: {
                        anticipationPercentage: 9.5,
                        coastingPercentage: 45.6,
                        cruiseControlPercentage: 45.6,
                        greenBandPercentage: 78.9,
                        highGradeRoadDrivingPercentage: 15.3,
                        highTorquePercentage: 23.4,
                        idlingPercentage: 12.8,
                        overSpeedPercentage: 5.6,
                        wearFreeBrakePercentage: 88.2,
                    },
                    rawData: {
                        anticipationBrakeEventCount: 17,
                        averageVehicleWeightKg: 14500,
                        coastingDurationMs: 1900800,
                        cruiseControlDurationMs: 3283200,
                        driveTimeDurationMs: 7200000,
                        engineOnDurationMs: 7500000,
                        greenBandDurationMs: 5683200,
                        highGradeRoadDrivingDurationMs: 1108800,
                        highTorqueDurationMs: 1684800,
                        idlingDurationMs: 921600,
                        overSpeedDurationMs: 403200,
                        totalBrakeDurationMs: 1022400,
                        totalBrakeEventCount: 85,
                        wearFreeBrakeDurationMs: 6340800,
                    },
                    scoreData: {
                        anticipationScore: "C",
                        coastingScore: "C",
                        cruiseControlScore: "B",
                        greenBandScore: "A",
                        highTorqueScore: "A",
                        idlingScore: "B",
                        overSpeedScore: "B",
                        overallScore: "A",
                        wearFreeBrakeScore: "A",
                    },
                    vehicleId: "vehicle_001",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
            startTime: "startTime",
            endTime: "endTime",
        });
        expect(response).toEqual({
            data: [
                {
                    difficultyScore: {
                        overallScore: "4",
                        topographyScore: "5",
                        vehicleWeightScore: "4",
                    },
                    percentageData: {
                        anticipationPercentage: 9.5,
                        coastingPercentage: 45.6,
                        cruiseControlPercentage: 45.6,
                        greenBandPercentage: 78.9,
                        highGradeRoadDrivingPercentage: 15.3,
                        highTorquePercentage: 23.4,
                        idlingPercentage: 12.8,
                        overSpeedPercentage: 5.6,
                        wearFreeBrakePercentage: 88.2,
                    },
                    rawData: {
                        anticipationBrakeEventCount: 17,
                        averageVehicleWeightKg: 14500,
                        coastingDurationMs: 1900800,
                        cruiseControlDurationMs: 3283200,
                        driveTimeDurationMs: 7200000,
                        engineOnDurationMs: 7500000,
                        greenBandDurationMs: 5683200,
                        highGradeRoadDrivingDurationMs: 1108800,
                        highTorqueDurationMs: 1684800,
                        idlingDurationMs: 921600,
                        overSpeedDurationMs: 403200,
                        totalBrakeDurationMs: 1022400,
                        totalBrakeEventCount: 85,
                        wearFreeBrakeDurationMs: 6340800,
                    },
                    scoreData: {
                        anticipationScore: "C",
                        coastingScore: "C",
                        cruiseControlScore: "B",
                        greenBandScore: "A",
                        highTorqueScore: "A",
                        idlingScore: "B",
                        overSpeedScore: "B",
                        overallScore: "A",
                        wearFreeBrakeScore: "A",
                    },
                    vehicleId: "vehicle_001",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getDriverEfficiencyByVehicles (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getDriverEfficiencyByVehicles (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getDriverEfficiencyByVehicles (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getDriverEfficiencyByVehicles (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getDriverEfficiencyByVehicles (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getDriverEfficiencyByVehicles (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getDriverEfficiencyByVehicles (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getDriverEfficiencyByVehicles (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getDriverEfficiencyByVehicles (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/driver-efficiency/vehicles")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getDriverEfficiencyByVehicles({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getFuelEnergyDriverReports (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: {
                driverReports: [
                    {
                        distanceTraveledMeters: 1384000,
                        driver: { id: "45646", name: "Driver Bob" },
                        efficiencyMpge: 21.4,
                        energyUsedKwh: 73.2,
                        engineIdleTimeDurationMs: 4320000,
                        engineRunTimeDurationMs: 576000,
                        estCarbonEmissionsKg: 22.7,
                        estFuelEnergyCost: { amount: 94.01, currencyCode: "USD" },
                        fuelConsumedMl: 162773,
                    },
                ],
            },
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.fuelAndEnergy.getFuelEnergyDriverReports({
            startDate: "startDate",
            endDate: "endDate",
        });
        expect(response).toEqual({
            data: {
                driverReports: [
                    {
                        distanceTraveledMeters: 1384000,
                        driver: {
                            id: "45646",
                            name: "Driver Bob",
                        },
                        efficiencyMpge: 21.4,
                        energyUsedKwh: 73.2,
                        engineIdleTimeDurationMs: 4320000,
                        engineRunTimeDurationMs: 576000,
                        estCarbonEmissionsKg: 22.7,
                        estFuelEnergyCost: {
                            amount: 94.01,
                            currencyCode: "USD",
                        },
                        fuelConsumedMl: 162773,
                    },
                ],
            },
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getFuelEnergyDriverReports (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getFuelEnergyDriverReports (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getFuelEnergyDriverReports (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getFuelEnergyDriverReports (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getFuelEnergyDriverReports (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getFuelEnergyDriverReports (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getFuelEnergyDriverReports (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getFuelEnergyDriverReports (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getFuelEnergyDriverReports (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/drivers/fuel-energy")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyDriverReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getFuelEnergyVehicleReports (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: {
                vehicleReports: [
                    {
                        distanceTraveledMeters: 1384000,
                        efficiencyMpge: 21.4,
                        energyUsedKwh: 73.2,
                        engineIdleTimeDurationMs: 4320000,
                        engineRunTimeDurationMs: 576000,
                        estCarbonEmissionsKg: 22.7,
                        estFuelEnergyCost: { amount: 94.01, currencyCode: "USD" },
                        fuelConsumedMl: 162773,
                        vehicle: { energyType: "fuel", id: "494123", name: "Fleet Truck #1" },
                    },
                ],
            },
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.fuelAndEnergy.getFuelEnergyVehicleReports({
            startDate: "startDate",
            endDate: "endDate",
        });
        expect(response).toEqual({
            data: {
                vehicleReports: [
                    {
                        distanceTraveledMeters: 1384000,
                        efficiencyMpge: 21.4,
                        energyUsedKwh: 73.2,
                        engineIdleTimeDurationMs: 4320000,
                        engineRunTimeDurationMs: 576000,
                        estCarbonEmissionsKg: 22.7,
                        estFuelEnergyCost: {
                            amount: 94.01,
                            currencyCode: "USD",
                        },
                        fuelConsumedMl: 162773,
                        vehicle: {
                            energyType: "fuel",
                            id: "494123",
                            name: "Fleet Truck #1",
                        },
                    },
                ],
            },
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getFuelEnergyVehicleReports (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getFuelEnergyVehicleReports (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getFuelEnergyVehicleReports (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getFuelEnergyVehicleReports (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getFuelEnergyVehicleReports (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getFuelEnergyVehicleReports (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getFuelEnergyVehicleReports (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getFuelEnergyVehicleReports (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getFuelEnergyVehicleReports (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/reports/vehicles/fuel-energy")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.getFuelEnergyVehicleReports({
                startDate: "startDate",
                endDate: "endDate",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("postFuelPurchase (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "676.8",
            transactionLocation: "350 Rhode Island St, San Francisco, CA 94103",
            transactionPrice: { amount: "640.2", currency: "usd" },
            transactionReference: "5454534",
            transactionTime: "2022-07-13T14:20:50.52-07:00",
        };
        const rawResponseBody = { data: { uuid: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7" } };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.fuelAndEnergy.postFuelPurchase({
            fuelQuantityLiters: "676.8",
            transactionLocation: "350 Rhode Island St, San Francisco, CA 94103",
            transactionPrice: {
                amount: "640.2",
                currency: "usd",
            },
            transactionReference: "5454534",
            transactionTime: "2022-07-13T14:20:50.52-07:00",
        });
        expect(response).toEqual({
            data: {
                uuid: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
            },
        });
    });

    test("postFuelPurchase (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("postFuelPurchase (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("postFuelPurchase (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("postFuelPurchase (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("postFuelPurchase (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("postFuelPurchase (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("postFuelPurchase (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("postFuelPurchase (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("postFuelPurchase (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fuelQuantityLiters: "fuelQuantityLiters",
            transactionLocation: "transactionLocation",
            transactionPrice: { amount: "amount", currency: "usd" },
            transactionReference: "x",
            transactionTime: "transactionTime",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/fuel-purchase")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.fuelAndEnergy.postFuelPurchase({
                fuelQuantityLiters: "fuelQuantityLiters",
                transactionLocation: "transactionLocation",
                transactionPrice: {
                    amount: "amount",
                    currency: "usd",
                },
                transactionReference: "x",
                transactionTime: "transactionTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });
});
