// This file was auto-generated by Fern from our API Definition.

import * as Samsara from "../../src/api/index";
import { SamsaraClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("BetaApisClient", () => {
    test("getDepreciationTransactions (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    amount: { amount: "640.2", currency: "usd" },
                    assetId: "281474993384538",
                    costCenterId: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
                    createdAt: "2024-12-05T10:30:00Z",
                    eventTime: "2024-11-30T23:59:59Z",
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    note: "November 2024 monthly depreciation",
                    transactionType: "depreciation",
                    updatedAt: "2024-12-05T10:30:00Z",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getDepreciationTransactions();
        expect(response).toEqual({
            data: [
                {
                    amount: {
                        amount: "640.2",
                        currency: "usd",
                    },
                    assetId: "281474993384538",
                    costCenterId: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
                    createdAt: "2024-12-05T10:30:00Z",
                    eventTime: "2024-11-30T23:59:59Z",
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    note: "November 2024 monthly depreciation",
                    transactionType: "depreciation",
                    updatedAt: "2024-12-05T10:30:00Z",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getDepreciationTransactions (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getDepreciationTransactions (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getDepreciationTransactions (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getDepreciationTransactions (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getDepreciationTransactions (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getDepreciationTransactions (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getDepreciationTransactions (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getDepreciationTransactions (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getDepreciationTransactions (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/depreciation")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDepreciationTransactions();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getAssetsInputs (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    asset: {
                        attributes: [
                            {
                                dateValues: ["dateValues", "dateValues"],
                                id: "id",
                                name: "name",
                                numberValues: [1.1, 1.1],
                                stringValues: ["stringValues", "stringValues"],
                            },
                            {
                                dateValues: ["dateValues", "dateValues"],
                                id: "id",
                                name: "name",
                                numberValues: [1.1, 1.1],
                                stringValues: ["stringValues", "stringValues"],
                            },
                        ],
                        externalIds: { externalIds: "externalIds" },
                        id: "id",
                        tags: [
                            { id: "id", name: "name", parentTagId: "parentTagId" },
                            { id: "id", name: "name", parentTagId: "parentTagId" },
                        ],
                    },
                    auxInput: { name: "name" },
                    happenedAtTime: "happenedAtTime",
                    units: "boolean",
                    value: "value",
                },
                {
                    asset: {
                        attributes: [
                            {
                                dateValues: ["dateValues", "dateValues"],
                                id: "id",
                                name: "name",
                                numberValues: [1.1, 1.1],
                                stringValues: ["stringValues", "stringValues"],
                            },
                            {
                                dateValues: ["dateValues", "dateValues"],
                                id: "id",
                                name: "name",
                                numberValues: [1.1, 1.1],
                                stringValues: ["stringValues", "stringValues"],
                            },
                        ],
                        externalIds: { externalIds: "externalIds" },
                        id: "id",
                        tags: [
                            { id: "id", name: "name", parentTagId: "parentTagId" },
                            { id: "id", name: "name", parentTagId: "parentTagId" },
                        ],
                    },
                    auxInput: { name: "name" },
                    happenedAtTime: "happenedAtTime",
                    units: "boolean",
                    value: "value",
                },
            ],
            pagination: { endCursor: "endCursor", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getAssetsInputs({
            type: "auxInput1",
            startTime: "startTime",
        });
        expect(response).toEqual({
            data: [
                {
                    asset: {
                        attributes: [
                            {
                                dateValues: ["dateValues", "dateValues"],
                                id: "id",
                                name: "name",
                                numberValues: [1.1, 1.1],
                                stringValues: ["stringValues", "stringValues"],
                            },
                            {
                                dateValues: ["dateValues", "dateValues"],
                                id: "id",
                                name: "name",
                                numberValues: [1.1, 1.1],
                                stringValues: ["stringValues", "stringValues"],
                            },
                        ],
                        externalIds: {
                            externalIds: "externalIds",
                        },
                        id: "id",
                        tags: [
                            {
                                id: "id",
                                name: "name",
                                parentTagId: "parentTagId",
                            },
                            {
                                id: "id",
                                name: "name",
                                parentTagId: "parentTagId",
                            },
                        ],
                    },
                    auxInput: {
                        name: "name",
                    },
                    happenedAtTime: "happenedAtTime",
                    units: "boolean",
                    value: "value",
                },
                {
                    asset: {
                        attributes: [
                            {
                                dateValues: ["dateValues", "dateValues"],
                                id: "id",
                                name: "name",
                                numberValues: [1.1, 1.1],
                                stringValues: ["stringValues", "stringValues"],
                            },
                            {
                                dateValues: ["dateValues", "dateValues"],
                                id: "id",
                                name: "name",
                                numberValues: [1.1, 1.1],
                                stringValues: ["stringValues", "stringValues"],
                            },
                        ],
                        externalIds: {
                            externalIds: "externalIds",
                        },
                        id: "id",
                        tags: [
                            {
                                id: "id",
                                name: "name",
                                parentTagId: "parentTagId",
                            },
                            {
                                id: "id",
                                name: "name",
                                parentTagId: "parentTagId",
                            },
                        ],
                    },
                    auxInput: {
                        name: "name",
                    },
                    happenedAtTime: "happenedAtTime",
                    units: "boolean",
                    value: "value",
                },
            ],
            pagination: {
                endCursor: "endCursor",
                hasNextPage: true,
            },
        });
    });

    test("getAssetsInputs (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getAssetsInputs (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getAssetsInputs (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getAssetsInputs (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getAssetsInputs (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getAssetsInputs (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getAssetsInputs (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getAssetsInputs (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getAssetsInputs (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/assets/inputs/stream")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAssetsInputs({
                type: "auxInput1",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getAempEquipmentList (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            Fleet: {
                Equipment: [
                    {
                        EquipmentHeader: {
                            EquipmentID: "494123",
                            Model: "S630 T4",
                            OEMName: "Bobcat",
                            PIN: "8V8WD530FLN016251",
                            SerialNumber: "8V8WD530FLN016251",
                            UnitInstallDateTime: "2019-06-13T19:08:25Z",
                        },
                        Location: { Latitude: 12.34, Longitude: 12.34, datetime: "2019-06-13T19:08:25Z" },
                    },
                ],
                Links: [{ href: "https://api.samsara.com/aemp/Fleet/1", rel: "self" }],
                snapshotTime: "2019-06-13T19:08:25Z",
                version: "1",
            },
        };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getAempEquipmentList("pageNumber");
        expect(response).toEqual({
            Fleet: {
                Equipment: [
                    {
                        EquipmentHeader: {
                            EquipmentID: "494123",
                            Model: "S630 T4",
                            OEMName: "Bobcat",
                            PIN: "8V8WD530FLN016251",
                            SerialNumber: "8V8WD530FLN016251",
                            UnitInstallDateTime: "2019-06-13T19:08:25Z",
                        },
                        Location: {
                            Latitude: 12.34,
                            Longitude: 12.34,
                            datetime: "2019-06-13T19:08:25Z",
                        },
                    },
                ],
                Links: [
                    {
                        href: "https://api.samsara.com/aemp/Fleet/1",
                        rel: "self",
                    },
                ],
                snapshotTime: "2019-06-13T19:08:25Z",
                version: "1",
            },
        });
    });

    test("getAempEquipmentList (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getAempEquipmentList (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getAempEquipmentList (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getAempEquipmentList (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getAempEquipmentList (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getAempEquipmentList (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getAempEquipmentList (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getAempEquipmentList (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getAempEquipmentList (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/aemp/Fleet/pageNumber")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getAempEquipmentList("pageNumber");
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getDriverEfficiency", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: {
                driverSummaries: [{}],
                summaryEndTime: "2020-03-16T16:00:00Z",
                summaryStartTime: "2020-03-15T16:00:00Z",
            },
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/beta/fleet/drivers/efficiency")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getDriverEfficiency();
        expect(response).toEqual({
            data: {
                driverSummaries: [{}],
                summaryEndTime: "2020-03-16T16:00:00Z",
                summaryStartTime: "2020-03-15T16:00:00Z",
            },
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("patchEquipment (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = {
            data: {
                attributes: [
                    {
                        dateValues: ["2024-01-15", "2024-12-31"],
                        id: "494123",
                        name: "Compliance/ELD",
                        numberValues: [867, 5309],
                        stringValues: ["HQ", "Leased"],
                    },
                ],
                equipmentSerialNumber: "8V8WD530FLN016251",
                externalIds: { key: "value" },
                id: "494123",
                installedGateway: { model: "AG15", serial: "GFRV-43N-VGX" },
                name: "Equipment-123",
                notes: "These are my equipment notes",
                tags: [{ id: "3914", name: "East Coast", parentTagId: "4815" }],
            },
        };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.patchEquipment("id");
        expect(response).toEqual({
            data: {
                attributes: [
                    {
                        dateValues: ["2024-01-15", "2024-12-31"],
                        id: "494123",
                        name: "Compliance/ELD",
                        numberValues: [867, 5309],
                        stringValues: ["HQ", "Leased"],
                    },
                ],
                equipmentSerialNumber: "8V8WD530FLN016251",
                externalIds: {
                    key: "value",
                },
                id: "494123",
                installedGateway: {
                    model: "AG15",
                    serial: "GFRV-43N-VGX",
                },
                name: "Equipment-123",
                notes: "These are my equipment notes",
                tags: [
                    {
                        id: "3914",
                        name: "East Coast",
                        parentTagId: "4815",
                    },
                ],
            },
        });
    });

    test("patchEquipment (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("patchEquipment (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("patchEquipment (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("patchEquipment (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("patchEquipment (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("patchEquipment (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("patchEquipment (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("patchEquipment (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("patchEquipment (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/equipment/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchEquipment("id");
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getHosEldEvents (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    driverActivationStatus: "active",
                    eldEvents: [
                        {
                            accumulatedVehicleMeters: 106,
                            elapsedEngineHours: 284.1,
                            eldEventCode: 3,
                            eldEventRecordOrigin: 2,
                            eldEventRecordStatus: 2,
                            eldEventType: 6,
                            remark: {
                                comment: "Pre-Trip Inspection",
                                locationDescription: "Near San Francisco",
                                time: "2019-06-13T19:08:25Z",
                            },
                            time: "2019-06-13T19:08:25Z",
                            totalEngineHours: 2894.1,
                            totalVehicleMeters: 1004566,
                        },
                    ],
                    externalIds: { key: "value" },
                    id: "494123",
                    name: "Joe Driver",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getHosEldEvents({
            startTime: "startTime",
            endTime: "endTime",
        });
        expect(response).toEqual({
            data: [
                {
                    driverActivationStatus: "active",
                    eldEvents: [
                        {
                            accumulatedVehicleMeters: 106,
                            elapsedEngineHours: 284.1,
                            eldEventCode: 3,
                            eldEventRecordOrigin: 2,
                            eldEventRecordStatus: 2,
                            eldEventType: 6,
                            remark: {
                                comment: "Pre-Trip Inspection",
                                locationDescription: "Near San Francisco",
                                time: "2019-06-13T19:08:25Z",
                            },
                            time: "2019-06-13T19:08:25Z",
                            totalEngineHours: 2894.1,
                            totalVehicleMeters: 1004566,
                        },
                    ],
                    externalIds: {
                        key: "value",
                    },
                    id: "494123",
                    name: "Joe Driver",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getHosEldEvents (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getHosEldEvents (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getHosEldEvents (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getHosEldEvents (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getHosEldEvents (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getHosEldEvents (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getHosEldEvents (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getHosEldEvents (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getHosEldEvents (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/hos/drivers/eld-events")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getHosEldEvents({
                startTime: "startTime",
                endTime: "endTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getTrailerStatsSnapshot (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    carrierReeferState: {
                        substateValue: "`Pretrip`, `Defrost`",
                        time: "2020-01-27T07:06:25Z",
                        value: "`Off`, `On`",
                    },
                    gps: {
                        headingDegrees: 7479278493048047000,
                        latitude: 0.3975329790494395,
                        longitude: 0.800368379601224,
                        speedMilesPerHour: 3123450857459408400,
                        time: "2020-01-27T07:06:25Z",
                    },
                    gpsOdometerMeters: { time: "2020-01-27T07:06:25Z", value: 50 },
                    id: "1234",
                    name: "Trailer-123",
                    reeferAlarms: {
                        alarms: [
                            {
                                alarmCode: "3",
                                description: "Test alarm",
                                operatorAction: "Manually disable alarm",
                                severity: 9025038144795927000,
                            },
                        ],
                        time: "2020-01-27T07:06:25Z",
                    },
                    reeferAmbientAirTemperatureMilliC: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferDoorStateZone1: { time: "2020-01-27T07:06:25Z", value: "open" },
                    reeferDoorStateZone2: { time: "2020-01-27T07:06:25Z", value: "open" },
                    reeferDoorStateZone3: { time: "2020-01-27T07:06:25Z", value: "open" },
                    reeferFuelPercent: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferObdEngineSeconds: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferReturnAirTemperatureMilliCZone1: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferReturnAirTemperatureMilliCZone2: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferReturnAirTemperatureMilliCZone3: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferRunMode: { time: "2020-01-27T07:06:25Z", value: "`Start/Stop`,`Continuous`" },
                    reeferSetPointTemperatureMilliCZone1: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferSetPointTemperatureMilliCZone2: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferSetPointTemperatureMilliCZone3: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferStateZone1: {
                        substateValue: "`Pretrip`, `Defrost`",
                        time: "2020-01-27T07:06:25Z",
                        value: "`Off`, `On`",
                    },
                    reeferStateZone2: {
                        substateValue: "`Pretrip`, `Defrost`",
                        time: "2020-01-27T07:06:25Z",
                        value: "`Off`, `On`",
                    },
                    reeferStateZone3: {
                        substateValue: "`Pretrip`, `Defrost`",
                        time: "2020-01-27T07:06:25Z",
                        value: "`Off`, `On`",
                    },
                    reeferSupplyAirTemperatureMilliCZone1: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferSupplyAirTemperatureMilliCZone2: { time: "2020-01-27T07:06:25Z", value: 50 },
                    reeferSupplyAirTemperatureMilliCZone3: { time: "2020-01-27T07:06:25Z", value: 50 },
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getTrailerStatsSnapshot({
            types: "types",
        });
        expect(response).toEqual({
            data: [
                {
                    carrierReeferState: {
                        substateValue: "`Pretrip`, `Defrost`",
                        time: "2020-01-27T07:06:25Z",
                        value: "`Off`, `On`",
                    },
                    gps: {
                        headingDegrees: 7479278493048047000,
                        latitude: 0.3975329790494395,
                        longitude: 0.800368379601224,
                        speedMilesPerHour: 3123450857459408400,
                        time: "2020-01-27T07:06:25Z",
                    },
                    gpsOdometerMeters: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    id: "1234",
                    name: "Trailer-123",
                    reeferAlarms: {
                        alarms: [
                            {
                                alarmCode: "3",
                                description: "Test alarm",
                                operatorAction: "Manually disable alarm",
                                severity: 9025038144795927000,
                            },
                        ],
                        time: "2020-01-27T07:06:25Z",
                    },
                    reeferAmbientAirTemperatureMilliC: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferDoorStateZone1: {
                        time: "2020-01-27T07:06:25Z",
                        value: "open",
                    },
                    reeferDoorStateZone2: {
                        time: "2020-01-27T07:06:25Z",
                        value: "open",
                    },
                    reeferDoorStateZone3: {
                        time: "2020-01-27T07:06:25Z",
                        value: "open",
                    },
                    reeferFuelPercent: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferObdEngineSeconds: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferReturnAirTemperatureMilliCZone1: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferReturnAirTemperatureMilliCZone2: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferReturnAirTemperatureMilliCZone3: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferRunMode: {
                        time: "2020-01-27T07:06:25Z",
                        value: "`Start/Stop`,`Continuous`",
                    },
                    reeferSetPointTemperatureMilliCZone1: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferSetPointTemperatureMilliCZone2: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferSetPointTemperatureMilliCZone3: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferStateZone1: {
                        substateValue: "`Pretrip`, `Defrost`",
                        time: "2020-01-27T07:06:25Z",
                        value: "`Off`, `On`",
                    },
                    reeferStateZone2: {
                        substateValue: "`Pretrip`, `Defrost`",
                        time: "2020-01-27T07:06:25Z",
                        value: "`Off`, `On`",
                    },
                    reeferStateZone3: {
                        substateValue: "`Pretrip`, `Defrost`",
                        time: "2020-01-27T07:06:25Z",
                        value: "`Off`, `On`",
                    },
                    reeferSupplyAirTemperatureMilliCZone1: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferSupplyAirTemperatureMilliCZone2: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                    reeferSupplyAirTemperatureMilliCZone3: {
                        time: "2020-01-27T07:06:25Z",
                        value: 50,
                    },
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getTrailerStatsSnapshot (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getTrailerStatsSnapshot (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getTrailerStatsSnapshot (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getTrailerStatsSnapshot (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getTrailerStatsSnapshot (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getTrailerStatsSnapshot (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getTrailerStatsSnapshot (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getTrailerStatsSnapshot (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getTrailerStatsSnapshot (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsSnapshot({
                types: "types",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getTrailerStatsFeed (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    carrierReeferState: [
                        { substateValue: "`Pretrip`, `Defrost`", time: "2020-01-27T07:06:25Z", value: "`Off`, `On`" },
                    ],
                    gps: [
                        {
                            headingDegrees: 3338069187406756000,
                            latitude: 0.46290561780530326,
                            longitude: 0.42542221587215867,
                            speedMilesPerHour: 1177010659956967000,
                            time: "2020-01-27T07:06:25Z",
                        },
                    ],
                    gpsOdometerMeters: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    id: "1234",
                    name: "Trailer-123",
                    reeferAlarms: [
                        {
                            alarms: [
                                {
                                    alarmCode: "3",
                                    description: "Test alarm",
                                    operatorAction: "Manually disable alarm",
                                    severity: 9025038144795927000,
                                },
                            ],
                            time: "2020-01-27T07:06:25Z",
                        },
                    ],
                    reeferAmbientAirTemperatureMilliC: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferDoorStateZone1: [{ time: "2020-01-27T07:06:25Z", value: "open" }],
                    reeferDoorStateZone2: [{ time: "2020-01-27T07:06:25Z", value: "open" }],
                    reeferDoorStateZone3: [{ time: "2020-01-27T07:06:25Z", value: "open" }],
                    reeferFuelPercent: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferObdEngineSeconds: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferReturnAirTemperatureMilliCZone1: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferReturnAirTemperatureMilliCZone2: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferReturnAirTemperatureMilliCZone3: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferRunMode: [{ time: "2020-01-27T07:06:25Z", value: "`Start/Stop`,`Continuous`" }],
                    reeferSetPointTemperatureMilliCZone1: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferSetPointTemperatureMilliCZone2: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferSetPointTemperatureMilliCZone3: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferStateZone1: [
                        { substateValue: "`Pretrip`, `Defrost`", time: "2020-01-27T07:06:25Z", value: "`Off`, `On`" },
                    ],
                    reeferStateZone2: [
                        { substateValue: "`Pretrip`, `Defrost`", time: "2020-01-27T07:06:25Z", value: "`Off`, `On`" },
                    ],
                    reeferStateZone3: [
                        { substateValue: "`Pretrip`, `Defrost`", time: "2020-01-27T07:06:25Z", value: "`Off`, `On`" },
                    ],
                    reeferSupplyAirTemperatureMilliCZone1: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferSupplyAirTemperatureMilliCZone2: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferSupplyAirTemperatureMilliCZone3: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getTrailerStatsFeed({
            types: "types",
        });
        expect(response).toEqual({
            data: [
                {
                    carrierReeferState: [
                        {
                            substateValue: "`Pretrip`, `Defrost`",
                            time: "2020-01-27T07:06:25Z",
                            value: "`Off`, `On`",
                        },
                    ],
                    gps: [
                        {
                            headingDegrees: 3338069187406756000,
                            latitude: 0.46290561780530326,
                            longitude: 0.42542221587215867,
                            speedMilesPerHour: 1177010659956967000,
                            time: "2020-01-27T07:06:25Z",
                        },
                    ],
                    gpsOdometerMeters: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    id: "1234",
                    name: "Trailer-123",
                    reeferAlarms: [
                        {
                            alarms: [
                                {
                                    alarmCode: "3",
                                    description: "Test alarm",
                                    operatorAction: "Manually disable alarm",
                                    severity: 9025038144795927000,
                                },
                            ],
                            time: "2020-01-27T07:06:25Z",
                        },
                    ],
                    reeferAmbientAirTemperatureMilliC: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferDoorStateZone1: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: "open",
                        },
                    ],
                    reeferDoorStateZone2: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: "open",
                        },
                    ],
                    reeferDoorStateZone3: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: "open",
                        },
                    ],
                    reeferFuelPercent: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferObdEngineSeconds: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferReturnAirTemperatureMilliCZone1: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferReturnAirTemperatureMilliCZone2: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferReturnAirTemperatureMilliCZone3: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferRunMode: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: "`Start/Stop`,`Continuous`",
                        },
                    ],
                    reeferSetPointTemperatureMilliCZone1: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferSetPointTemperatureMilliCZone2: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferSetPointTemperatureMilliCZone3: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferStateZone1: [
                        {
                            substateValue: "`Pretrip`, `Defrost`",
                            time: "2020-01-27T07:06:25Z",
                            value: "`Off`, `On`",
                        },
                    ],
                    reeferStateZone2: [
                        {
                            substateValue: "`Pretrip`, `Defrost`",
                            time: "2020-01-27T07:06:25Z",
                            value: "`Off`, `On`",
                        },
                    ],
                    reeferStateZone3: [
                        {
                            substateValue: "`Pretrip`, `Defrost`",
                            time: "2020-01-27T07:06:25Z",
                            value: "`Off`, `On`",
                        },
                    ],
                    reeferSupplyAirTemperatureMilliCZone1: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferSupplyAirTemperatureMilliCZone2: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferSupplyAirTemperatureMilliCZone3: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getTrailerStatsFeed (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getTrailerStatsFeed (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getTrailerStatsFeed (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getTrailerStatsFeed (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getTrailerStatsFeed (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getTrailerStatsFeed (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getTrailerStatsFeed (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getTrailerStatsFeed (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getTrailerStatsFeed (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/feed")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsFeed({
                types: "types",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getTrailerStatsHistory (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    carrierReeferState: [
                        { substateValue: "`Pretrip`, `Defrost`", time: "2020-01-27T07:06:25Z", value: "`Off`, `On`" },
                    ],
                    gps: [
                        {
                            headingDegrees: 3338069187406756000,
                            latitude: 0.46290561780530326,
                            longitude: 0.42542221587215867,
                            speedMilesPerHour: 1177010659956967000,
                            time: "2020-01-27T07:06:25Z",
                        },
                    ],
                    gpsOdometerMeters: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    id: "1234",
                    name: "Trailer-123",
                    reeferAlarms: [
                        {
                            alarms: [
                                {
                                    alarmCode: "3",
                                    description: "Test alarm",
                                    operatorAction: "Manually disable alarm",
                                    severity: 9025038144795927000,
                                },
                            ],
                            time: "2020-01-27T07:06:25Z",
                        },
                    ],
                    reeferAmbientAirTemperatureMilliC: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferDoorStateZone1: [{ time: "2020-01-27T07:06:25Z", value: "open" }],
                    reeferDoorStateZone2: [{ time: "2020-01-27T07:06:25Z", value: "open" }],
                    reeferDoorStateZone3: [{ time: "2020-01-27T07:06:25Z", value: "open" }],
                    reeferFuelPercent: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferObdEngineSeconds: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferReturnAirTemperatureMilliCZone1: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferReturnAirTemperatureMilliCZone2: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferReturnAirTemperatureMilliCZone3: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferRunMode: [{ time: "2020-01-27T07:06:25Z", value: "`Start/Stop`,`Continuous`" }],
                    reeferSetPointTemperatureMilliCZone1: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferSetPointTemperatureMilliCZone2: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferSetPointTemperatureMilliCZone3: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferStateZone1: [
                        { substateValue: "`Pretrip`, `Defrost`", time: "2020-01-27T07:06:25Z", value: "`Off`, `On`" },
                    ],
                    reeferStateZone2: [
                        { substateValue: "`Pretrip`, `Defrost`", time: "2020-01-27T07:06:25Z", value: "`Off`, `On`" },
                    ],
                    reeferStateZone3: [
                        { substateValue: "`Pretrip`, `Defrost`", time: "2020-01-27T07:06:25Z", value: "`Off`, `On`" },
                    ],
                    reeferSupplyAirTemperatureMilliCZone1: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferSupplyAirTemperatureMilliCZone2: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                    reeferSupplyAirTemperatureMilliCZone3: [{ time: "2020-01-27T07:06:25Z", value: 50 }],
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getTrailerStatsHistory({
            startTime: "startTime",
            endTime: "endTime",
            types: "types",
        });
        expect(response).toEqual({
            data: [
                {
                    carrierReeferState: [
                        {
                            substateValue: "`Pretrip`, `Defrost`",
                            time: "2020-01-27T07:06:25Z",
                            value: "`Off`, `On`",
                        },
                    ],
                    gps: [
                        {
                            headingDegrees: 3338069187406756000,
                            latitude: 0.46290561780530326,
                            longitude: 0.42542221587215867,
                            speedMilesPerHour: 1177010659956967000,
                            time: "2020-01-27T07:06:25Z",
                        },
                    ],
                    gpsOdometerMeters: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    id: "1234",
                    name: "Trailer-123",
                    reeferAlarms: [
                        {
                            alarms: [
                                {
                                    alarmCode: "3",
                                    description: "Test alarm",
                                    operatorAction: "Manually disable alarm",
                                    severity: 9025038144795927000,
                                },
                            ],
                            time: "2020-01-27T07:06:25Z",
                        },
                    ],
                    reeferAmbientAirTemperatureMilliC: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferDoorStateZone1: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: "open",
                        },
                    ],
                    reeferDoorStateZone2: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: "open",
                        },
                    ],
                    reeferDoorStateZone3: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: "open",
                        },
                    ],
                    reeferFuelPercent: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferObdEngineSeconds: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferReturnAirTemperatureMilliCZone1: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferReturnAirTemperatureMilliCZone2: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferReturnAirTemperatureMilliCZone3: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferRunMode: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: "`Start/Stop`,`Continuous`",
                        },
                    ],
                    reeferSetPointTemperatureMilliCZone1: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferSetPointTemperatureMilliCZone2: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferSetPointTemperatureMilliCZone3: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferStateZone1: [
                        {
                            substateValue: "`Pretrip`, `Defrost`",
                            time: "2020-01-27T07:06:25Z",
                            value: "`Off`, `On`",
                        },
                    ],
                    reeferStateZone2: [
                        {
                            substateValue: "`Pretrip`, `Defrost`",
                            time: "2020-01-27T07:06:25Z",
                            value: "`Off`, `On`",
                        },
                    ],
                    reeferStateZone3: [
                        {
                            substateValue: "`Pretrip`, `Defrost`",
                            time: "2020-01-27T07:06:25Z",
                            value: "`Off`, `On`",
                        },
                    ],
                    reeferSupplyAirTemperatureMilliCZone1: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferSupplyAirTemperatureMilliCZone2: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                    reeferSupplyAirTemperatureMilliCZone3: [
                        {
                            time: "2020-01-27T07:06:25Z",
                            value: 50,
                        },
                    ],
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getTrailerStatsHistory (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getTrailerStatsHistory (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getTrailerStatsHistory (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getTrailerStatsHistory (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getTrailerStatsHistory (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getTrailerStatsHistory (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getTrailerStatsHistory (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getTrailerStatsHistory (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getTrailerStatsHistory (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/fleet/trailers/stats/history")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTrailerStatsHistory({
                startTime: "startTime",
                endTime: "endTime",
                types: "types",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("updateEngineImmobilizerState (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { relayStates: [{ id: "relay1", isOpen: true }] };

        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.betaApis.updateEngineImmobilizerState(1000000, {
            relayStates: [
                {
                    id: "relay1",
                    isOpen: true,
                },
            ],
        });
        expect(response).toEqual(undefined);
    });

    test("updateEngineImmobilizerState (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("updateEngineImmobilizerState (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("updateEngineImmobilizerState (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("updateEngineImmobilizerState (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("updateEngineImmobilizerState (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("updateEngineImmobilizerState (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("updateEngineImmobilizerState (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("updateEngineImmobilizerState (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("updateEngineImmobilizerState (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            relayStates: [
                { id: "relay1", isOpen: true },
                { id: "relay1", isOpen: true },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/fleet/vehicles/1000000/immobilizer")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateEngineImmobilizerState(1000000, {
                relayStates: [
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                    {
                        id: "relay1",
                        isOpen: true,
                    },
                ],
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getJobs (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    address: {
                        address: "1990 Alameda st, San Francisco, Ca 94103",
                        latitude: 37.456345,
                        longitude: 34.5633749,
                        name: "Worksite #1",
                    },
                    createdAt: "2019-06-13T19:08:25Z",
                    customerName: "Samsara",
                    endDate: "2019-06-13T19:08:25Z",
                    fleetDevices: [{ id: 123456, name: "My Device" }],
                    id: "1553",
                    industrialAssets: [{ id: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596", name: "My asset" }],
                    modifiedAt: "2019-06-13T19:08:25Z",
                    name: "My Job Name",
                    notes: "These are my notes",
                    ontimeWindowAfterArrivalMs: 300000,
                    ontimeWindowBeforeArrivalMs: 300000,
                    startDate: "2019-06-13T19:08:25Z",
                    status: "active",
                    uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
                },
            ],
            id: "1553",
            pagination: { endCursor: "MjkY", hasNextPage: true },
            uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
        };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getJobs();
        expect(response).toEqual({
            data: [
                {
                    address: {
                        address: "1990 Alameda st, San Francisco, Ca 94103",
                        latitude: 37.456345,
                        longitude: 34.5633749,
                        name: "Worksite #1",
                    },
                    createdAt: "2019-06-13T19:08:25Z",
                    customerName: "Samsara",
                    endDate: "2019-06-13T19:08:25Z",
                    fleetDevices: [
                        {
                            id: 123456,
                            name: "My Device",
                        },
                    ],
                    id: "1553",
                    industrialAssets: [
                        {
                            id: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
                            name: "My asset",
                        },
                    ],
                    modifiedAt: "2019-06-13T19:08:25Z",
                    name: "My Job Name",
                    notes: "These are my notes",
                    ontimeWindowAfterArrivalMs: 300000,
                    ontimeWindowBeforeArrivalMs: 300000,
                    startDate: "2019-06-13T19:08:25Z",
                    status: "active",
                    uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
                },
            ],
            id: "1553",
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
            uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
        });
    });

    test("getJobs (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getJobs (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getJobs (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getJobs (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getJobs (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getJobs (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getJobs (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getJobs (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getJobs (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/beta/industrial/jobs")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getJobs();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("createJob (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            job: {
                endDate: "2019-06-13T19:08:25Z",
                id: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
                name: "My Job Name",
                startDate: "2019-06-13T19:08:25Z",
            },
        };
        const rawResponseBody = {
            data: {
                address: {
                    address: "1990 Alameda st, San Francisco, Ca 94103",
                    latitude: 37.456345,
                    longitude: 34.5633749,
                    name: "Worksite #1",
                },
                createdAt: "2019-06-13T19:08:25Z",
                customerName: "Samsara",
                endDate: "2019-06-13T19:08:25Z",
                fleetDevices: [{ id: 123456, name: "My Device" }],
                id: "1553",
                industrialAssets: [{ id: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596", name: "My asset" }],
                modifiedAt: "2019-06-13T19:08:25Z",
                name: "My Job Name",
                notes: "These are my notes",
                ontimeWindowAfterArrivalMs: 300000,
                ontimeWindowBeforeArrivalMs: 300000,
                startDate: "2019-06-13T19:08:25Z",
                status: "active",
                uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
            },
            id: "1553",
            uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
        };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.createJob({
            job: {
                endDate: "2019-06-13T19:08:25Z",
                id: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
                name: "My Job Name",
                startDate: "2019-06-13T19:08:25Z",
            },
        });
        expect(response).toEqual({
            data: {
                address: {
                    address: "1990 Alameda st, San Francisco, Ca 94103",
                    latitude: 37.456345,
                    longitude: 34.5633749,
                    name: "Worksite #1",
                },
                createdAt: "2019-06-13T19:08:25Z",
                customerName: "Samsara",
                endDate: "2019-06-13T19:08:25Z",
                fleetDevices: [
                    {
                        id: 123456,
                        name: "My Device",
                    },
                ],
                id: "1553",
                industrialAssets: [
                    {
                        id: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
                        name: "My asset",
                    },
                ],
                modifiedAt: "2019-06-13T19:08:25Z",
                name: "My Job Name",
                notes: "These are my notes",
                ontimeWindowAfterArrivalMs: 300000,
                ontimeWindowBeforeArrivalMs: 300000,
                startDate: "2019-06-13T19:08:25Z",
                status: "active",
                uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
            },
            id: "1553",
            uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
        });
    });

    test("createJob (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("createJob (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("createJob (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("createJob (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("createJob (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("createJob (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("createJob (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("createJob (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("createJob (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: { endDate: "endDate", id: "id", name: "name", startDate: "startDate" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createJob({
                job: {
                    endDate: "endDate",
                    id: "id",
                    name: "name",
                    startDate: "startDate",
                },
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("deleteJob (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { id: "1553", uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.deleteJob({
            id: "id",
        });
        expect(response).toEqual({
            id: "1553",
            uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
        });
    });

    test("deleteJob (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("deleteJob (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("deleteJob (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("deleteJob (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("deleteJob (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("deleteJob (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("deleteJob (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("deleteJob (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("deleteJob (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/beta/industrial/jobs")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteJob({
                id: "id",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("patchJob (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = {
            data: {
                address: {
                    address: "1990 Alameda st, San Francisco, Ca 94103",
                    latitude: 37.456345,
                    longitude: 34.5633749,
                    name: "Worksite #1",
                },
                createdAt: "2019-06-13T19:08:25Z",
                customerName: "Samsara",
                endDate: "2019-06-13T19:08:25Z",
                fleetDevices: [{ id: 123456, name: "My Device" }],
                id: "1553",
                industrialAssets: [{ id: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596", name: "My asset" }],
                modifiedAt: "2019-06-13T19:08:25Z",
                name: "My Job Name",
                notes: "These are my notes",
                ontimeWindowAfterArrivalMs: 300000,
                ontimeWindowBeforeArrivalMs: 300000,
                startDate: "2019-06-13T19:08:25Z",
                status: "active",
                uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
            },
            id: "1553",
            uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
        };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.patchJob({
            id: "id",
            job: {},
        });
        expect(response).toEqual({
            data: {
                address: {
                    address: "1990 Alameda st, San Francisco, Ca 94103",
                    latitude: 37.456345,
                    longitude: 34.5633749,
                    name: "Worksite #1",
                },
                createdAt: "2019-06-13T19:08:25Z",
                customerName: "Samsara",
                endDate: "2019-06-13T19:08:25Z",
                fleetDevices: [
                    {
                        id: 123456,
                        name: "My Device",
                    },
                ],
                id: "1553",
                industrialAssets: [
                    {
                        id: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
                        name: "My asset",
                    },
                ],
                modifiedAt: "2019-06-13T19:08:25Z",
                name: "My Job Name",
                notes: "These are my notes",
                ontimeWindowAfterArrivalMs: 300000,
                ontimeWindowBeforeArrivalMs: 300000,
                startDate: "2019-06-13T19:08:25Z",
                status: "active",
                uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
            },
            id: "1553",
            uuid: "8d218e6c-7a16-4f9f-90f7-cc1d93b9e596",
        });
    });

    test("patchJob (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("patchJob (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("patchJob (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("patchJob (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("patchJob (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("patchJob (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("patchJob (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("patchJob (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("patchJob (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { job: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/beta/industrial/jobs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchJob({
                id: "id",
                job: {},
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getDetections (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    asset: {
                        id: "asset-23ab7cd1-5f6e-4c9b-8f21-1e3b7a9c4d8f",
                        name: "Truck 102 - Volvo VNL",
                        tags: [{ id: "3914", name: "East Coast", parentTagId: "4815" }],
                    },
                    createdAtTime: "2025-09-20T11:15:30Z",
                    driver: {
                        id: "driver-8b12fa3d-3c6e-4e2a-9a76-24c1f7b23d9a",
                        name: "Alex Johnson",
                        tags: [{ id: "3914", name: "East Coast", parentTagId: "4815" }],
                    },
                    id: "9c4f81d2-7a25-4f8c-9b83-1c34a91e34a1",
                    inCabAlertPlayed: true,
                    safetyEvent: [{ id: "a1b2c3d4-5678-90ab-cdef-1234567890ab", inboxEvent: false }],
                    triggerDetectionLabel: "acceleration",
                    updatedAtTime: "2025-09-20T11:20:45Z",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.betaApis.getDetections({
            startTime: "startTime",
        });
        expect(response).toEqual({
            data: [
                {
                    asset: {
                        id: "asset-23ab7cd1-5f6e-4c9b-8f21-1e3b7a9c4d8f",
                        name: "Truck 102 - Volvo VNL",
                        tags: [
                            {
                                id: "3914",
                                name: "East Coast",
                                parentTagId: "4815",
                            },
                        ],
                    },
                    createdAtTime: "2025-09-20T11:15:30Z",
                    driver: {
                        id: "driver-8b12fa3d-3c6e-4e2a-9a76-24c1f7b23d9a",
                        name: "Alex Johnson",
                        tags: [
                            {
                                id: "3914",
                                name: "East Coast",
                                parentTagId: "4815",
                            },
                        ],
                    },
                    id: "9c4f81d2-7a25-4f8c-9b83-1c34a91e34a1",
                    inCabAlertPlayed: true,
                    safetyEvent: [
                        {
                            id: "a1b2c3d4-5678-90ab-cdef-1234567890ab",
                            inboxEvent: false,
                        },
                    ],
                    triggerDetectionLabel: "acceleration",
                    updatedAtTime: "2025-09-20T11:20:45Z",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getDetections (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getDetections (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getDetections (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(405).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getDetections (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getDetections (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getDetections (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(501).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getDetections (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(502).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getDetections (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(503).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getDetections (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/detections/stream").respondWith().statusCode(504).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDetections({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getDevices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    asset: { id: "281474982859091", name: "MyAsset-1234" },
                    health: { primaryHealthReasonStartTime: "2019-06-13T19:08:25Z" },
                    lastConnectedTime: "2019-06-13T19:08:25Z",
                    lastKnownLocation: { id: 12345, latitude: 12333122.3, longitude: 1233331.4 },
                    model: "AG24",
                    serial: "ABCD-123-EFG",
                    tags: [{ id: "3914", name: "East Coast", parentTagId: "4815" }],
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server.mockEndpoint().get("/devices").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.betaApis.getDevices();
        expect(response).toEqual({
            data: [
                {
                    asset: {
                        id: "281474982859091",
                        name: "MyAsset-1234",
                    },
                    health: {
                        primaryHealthReasonStartTime: "2019-06-13T19:08:25Z",
                    },
                    lastConnectedTime: "2019-06-13T19:08:25Z",
                    lastKnownLocation: {
                        id: 12345,
                        latitude: 12333122.3,
                        longitude: 1233331.4,
                    },
                    model: "AG24",
                    serial: "ABCD-123-EFG",
                    tags: [
                        {
                            id: "3914",
                            name: "East Coast",
                            parentTagId: "4815",
                        },
                    ],
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getDevices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getDevices (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getDevices (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(405).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getDevices (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getDevices (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getDevices (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(501).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getDevices (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(502).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getDevices (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(503).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getDevices (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/devices").respondWith().statusCode(504).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDevices();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getEngineImmobilizerStates (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    happenedAtTime: "2019-06-13T19:08:25Z",
                    isConnectedToVehicle: false,
                    relayStates: [{ id: "relay1", isOpen: false }],
                    vehicleId: "1234",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getEngineImmobilizerStates({
            vehicleIds: "vehicleIds",
            startTime: "startTime",
        });
        expect(response).toEqual({
            data: [
                {
                    happenedAtTime: "2019-06-13T19:08:25Z",
                    isConnectedToVehicle: false,
                    relayStates: [
                        {
                            id: "relay1",
                            isOpen: false,
                        },
                    ],
                    vehicleId: "1234",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getEngineImmobilizerStates (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getEngineImmobilizerStates (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getEngineImmobilizerStates (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getEngineImmobilizerStates (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getEngineImmobilizerStates (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getEngineImmobilizerStates (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getEngineImmobilizerStates (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getEngineImmobilizerStates (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getEngineImmobilizerStates (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/fleet/vehicles/immobilizer/stream")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getEngineImmobilizerStates({
                vehicleIds: "vehicleIds",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("startFunctionRun (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { data: { correlationId: "550e8400-e29b-41d4-a716-446655440000" } };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.startFunctionRun("name", {
            paramsOverride: {},
        });
        expect(response).toEqual({
            data: {
                correlationId: "550e8400-e29b-41d4-a716-446655440000",
            },
        });
    });

    test("startFunctionRun (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("startFunctionRun (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("startFunctionRun (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("startFunctionRun (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("startFunctionRun (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("startFunctionRun (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("startFunctionRun (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("startFunctionRun (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("startFunctionRun (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { paramsOverride: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/functions/name/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.startFunctionRun("name", {
                paramsOverride: {},
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("updateShippingDocs (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "ShippingID1, ShippingID2" };
        const rawResponseBody = {
            data: {
                adverseDrivingClaimed: false,
                bigDayClaimed: true,
                carrierFormattedAddress: "1990 Alameda Street, San Francisco, CA 94103",
                carrierName: "Carrier Name",
                carrierUsDotNumber: 1234,
                homeTerminalFormattedAddress: "1990 Alameda Street, San Francisco, CA 94103",
                homeTerminalName: "Home Terminal Name",
                isCertified: true,
                isUsShortHaulActive: true,
                trailerNames: ["10293", "Trailer ID 1"],
            },
        };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.updateShippingDocs({
            hosDate: "hosDate",
            driverID: "driverID",
            shippingDocs: "ShippingID1, ShippingID2",
        });
        expect(response).toEqual({
            data: {
                adverseDrivingClaimed: false,
                bigDayClaimed: true,
                carrierFormattedAddress: "1990 Alameda Street, San Francisco, CA 94103",
                carrierName: "Carrier Name",
                carrierUsDotNumber: 1234,
                homeTerminalFormattedAddress: "1990 Alameda Street, San Francisco, CA 94103",
                homeTerminalName: "Home Terminal Name",
                isCertified: true,
                isUsShortHaulActive: true,
                trailerNames: ["10293", "Trailer ID 1"],
            },
        });
    });

    test("updateShippingDocs (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("updateShippingDocs (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("updateShippingDocs (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("updateShippingDocs (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("updateShippingDocs (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("updateShippingDocs (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("updateShippingDocs (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("updateShippingDocs (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("updateShippingDocs (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { shippingDocs: "shippingDocs" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/hos/daily-logs/log-meta-data")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.updateShippingDocs({
                hosDate: "hosDate",
                driverID: "driverID",
                shippingDocs: "shippingDocs",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("listHubCustomProperties (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    createdAt: "2024-01-15T10:30:00Z",
                    csvColumns: "customer_type,customerType",
                    hubId: "650e8400-e29b-41d4-a716-446655440001",
                    id: "750e8400-e29b-41d4-a716-446655440004",
                    name: "CustomerType",
                    updatedAt: "2024-01-15T10:30:00Z",
                },
            ],
            pagination: { endCursor: "YXJyYXljb25uZWN0aW9uOjEwMA==", hasNextPage: false },
        };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.listHubCustomProperties({
            hubId: "hubId",
        });
        expect(response).toEqual({
            data: [
                {
                    createdAt: "2024-01-15T10:30:00Z",
                    csvColumns: "customer_type,customerType",
                    hubId: "650e8400-e29b-41d4-a716-446655440001",
                    id: "750e8400-e29b-41d4-a716-446655440004",
                    name: "CustomerType",
                    updatedAt: "2024-01-15T10:30:00Z",
                },
            ],
            pagination: {
                endCursor: "YXJyYXljb25uZWN0aW9uOjEwMA==",
                hasNextPage: false,
            },
        });
    });

    test("listHubCustomProperties (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("listHubCustomProperties (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("listHubCustomProperties (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("listHubCustomProperties (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("listHubCustomProperties (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("listHubCustomProperties (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("listHubCustomProperties (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("listHubCustomProperties (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("listHubCustomProperties (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/hub/customProperties")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listHubCustomProperties({
                hubId: "hubId",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("createPlanOrders (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    customerOrderId: "ORDER-2024-001",
                    hubId: "550e8400-e29b-41d4-a716-446655440000",
                    planId: "650e8400-e29b-41d4-a716-446655440023",
                },
            ],
        };
        const rawResponseBody = {
            data: [
                {
                    createdAt: "2024-04-10T11:30:00Z",
                    customProperties: [
                        {
                            customPropertyId: "750e8400-e29b-41d4-a716-446655440004",
                            name: "CustomerType",
                            value: "Premium",
                        },
                    ],
                    customerOrderId: "ORDER-2024-001",
                    delivery: {
                        address: "123 Business Way, San Francisco",
                        appointmentWindow: { endTime: "2024-04-10T17:00:00Z", startTime: "2024-04-10T09:00:00Z" },
                        customerLocationId: "LOC-123",
                        latitude: 37.7749,
                        longitude: -122.4194,
                        notes: "Use main entrance",
                        serviceTimeSeconds: 600,
                    },
                    hubId: "550e8400-e29b-41d4-a716-446655440000",
                    id: "a50e8400-e29b-41d4-a716-446655440006",
                    pickup: {
                        address: "123 Business Way, San Francisco",
                        appointmentWindow: { endTime: "2024-04-10T17:00:00Z", startTime: "2024-04-10T09:00:00Z" },
                        customerLocationId: "LOC-123",
                        latitude: 37.7749,
                        longitude: -122.4194,
                        notes: "Use main entrance",
                        serviceTimeSeconds: 600,
                    },
                    planId: "650e8400-e29b-41d4-a716-446655440023",
                    priority: 1,
                    quantities: [{ capacityId: "850e8400-e29b-41d4-a716-446655440003", quantity: 25.5 }],
                    skillsRequired: ["650e8400-e29b-41d4-a716-446655440001", "650e8400-e29b-41d4-a716-446655440001"],
                    updatedAt: "2024-04-10T11:30:00Z",
                },
            ],
        };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.createPlanOrders({
            data: [
                {
                    customerOrderId: "ORDER-2024-001",
                    hubId: "550e8400-e29b-41d4-a716-446655440000",
                    planId: "650e8400-e29b-41d4-a716-446655440023",
                },
            ],
        });
        expect(response).toEqual({
            data: [
                {
                    createdAt: "2024-04-10T11:30:00Z",
                    customProperties: [
                        {
                            customPropertyId: "750e8400-e29b-41d4-a716-446655440004",
                            name: "CustomerType",
                            value: "Premium",
                        },
                    ],
                    customerOrderId: "ORDER-2024-001",
                    delivery: {
                        address: "123 Business Way, San Francisco",
                        appointmentWindow: {
                            endTime: "2024-04-10T17:00:00Z",
                            startTime: "2024-04-10T09:00:00Z",
                        },
                        customerLocationId: "LOC-123",
                        latitude: 37.7749,
                        longitude: -122.4194,
                        notes: "Use main entrance",
                        serviceTimeSeconds: 600,
                    },
                    hubId: "550e8400-e29b-41d4-a716-446655440000",
                    id: "a50e8400-e29b-41d4-a716-446655440006",
                    pickup: {
                        address: "123 Business Way, San Francisco",
                        appointmentWindow: {
                            endTime: "2024-04-10T17:00:00Z",
                            startTime: "2024-04-10T09:00:00Z",
                        },
                        customerLocationId: "LOC-123",
                        latitude: 37.7749,
                        longitude: -122.4194,
                        notes: "Use main entrance",
                        serviceTimeSeconds: 600,
                    },
                    planId: "650e8400-e29b-41d4-a716-446655440023",
                    priority: 1,
                    quantities: [
                        {
                            capacityId: "850e8400-e29b-41d4-a716-446655440003",
                            quantity: 25.5,
                        },
                    ],
                    skillsRequired: ["650e8400-e29b-41d4-a716-446655440001", "650e8400-e29b-41d4-a716-446655440001"],
                    updatedAt: "2024-04-10T11:30:00Z",
                },
            ],
        });
    });

    test("createPlanOrders (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("createPlanOrders (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("createPlanOrders (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("createPlanOrders (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("createPlanOrders (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("createPlanOrders (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("createPlanOrders (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("createPlanOrders (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("createPlanOrders (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
                { customerOrderId: "customerOrderId", hubId: "hubId", planId: "planId" },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/hub/plan/orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createPlanOrders({
                data: [
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                    {
                        customerOrderId: "customerOrderId",
                        hubId: "hubId",
                        planId: "planId",
                    },
                ],
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getQualificationRecords (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    createdAtTime: "2024-01-15T09:30:00Z",
                    createdBy: { id: "id", type: "driver" },
                    expirationDate: "2024-01-15T09:30:00Z",
                    externalIds: { externalIds: "externalIds" },
                    fields: [
                        {
                            checkBoxesValue: { value: ["value", "value"], valueIds: ["valueIds", "valueIds"] },
                            dateTimeValue: { type: "datetime", value: "2024-01-15T09:30:00Z" },
                            id: "id",
                            label: "label",
                            mediaList: [
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            ],
                            multipleChoiceValue: { value: "value", valueId: "valueId" },
                            numberValue: { value: 1.1 },
                            signatureValue: {
                                media: {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    { id: "id", label: "label", type: "text" },
                                    { id: "id", label: "label", type: "text" },
                                ],
                                rows: [
                                    { cells: [], id: "id" },
                                    { cells: [], id: "id" },
                                ],
                            },
                            textValue: { value: "value" },
                            type: "number",
                        },
                        {
                            checkBoxesValue: { value: ["value", "value"], valueIds: ["valueIds", "valueIds"] },
                            dateTimeValue: { type: "datetime", value: "2024-01-15T09:30:00Z" },
                            id: "id",
                            label: "label",
                            mediaList: [
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            ],
                            multipleChoiceValue: { value: "value", valueId: "valueId" },
                            numberValue: { value: 1.1 },
                            signatureValue: {
                                media: {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    { id: "id", label: "label", type: "text" },
                                    { id: "id", label: "label", type: "text" },
                                ],
                                rows: [
                                    { cells: [], id: "id" },
                                    { cells: [], id: "id" },
                                ],
                            },
                            textValue: { value: "value" },
                            type: "number",
                        },
                    ],
                    id: "id",
                    issueDate: "2024-01-15T09:30:00Z",
                    owner: { entityType: "worker", externalIds: { externalIds: "externalIds" }, id: "id" },
                    qualificationType: { id: "id", name: "name", revisionId: "revisionId" },
                    recordStatus: "active",
                    updatedAtTime: "2024-01-15T09:30:00Z",
                    updatedBy: { id: "id", type: "driver" },
                },
                {
                    createdAtTime: "2024-01-15T09:30:00Z",
                    createdBy: { id: "id", type: "driver" },
                    expirationDate: "2024-01-15T09:30:00Z",
                    externalIds: { externalIds: "externalIds" },
                    fields: [
                        {
                            checkBoxesValue: { value: ["value", "value"], valueIds: ["valueIds", "valueIds"] },
                            dateTimeValue: { type: "datetime", value: "2024-01-15T09:30:00Z" },
                            id: "id",
                            label: "label",
                            mediaList: [
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            ],
                            multipleChoiceValue: { value: "value", valueId: "valueId" },
                            numberValue: { value: 1.1 },
                            signatureValue: {
                                media: {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    { id: "id", label: "label", type: "text" },
                                    { id: "id", label: "label", type: "text" },
                                ],
                                rows: [
                                    { cells: [], id: "id" },
                                    { cells: [], id: "id" },
                                ],
                            },
                            textValue: { value: "value" },
                            type: "number",
                        },
                        {
                            checkBoxesValue: { value: ["value", "value"], valueIds: ["valueIds", "valueIds"] },
                            dateTimeValue: { type: "datetime", value: "2024-01-15T09:30:00Z" },
                            id: "id",
                            label: "label",
                            mediaList: [
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            ],
                            multipleChoiceValue: { value: "value", valueId: "valueId" },
                            numberValue: { value: 1.1 },
                            signatureValue: {
                                media: {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    { id: "id", label: "label", type: "text" },
                                    { id: "id", label: "label", type: "text" },
                                ],
                                rows: [
                                    { cells: [], id: "id" },
                                    { cells: [], id: "id" },
                                ],
                            },
                            textValue: { value: "value" },
                            type: "number",
                        },
                    ],
                    id: "id",
                    issueDate: "2024-01-15T09:30:00Z",
                    owner: { entityType: "worker", externalIds: { externalIds: "externalIds" }, id: "id" },
                    qualificationType: { id: "id", name: "name", revisionId: "revisionId" },
                    recordStatus: "active",
                    updatedAtTime: "2024-01-15T09:30:00Z",
                    updatedBy: { id: "id", type: "driver" },
                },
            ],
        };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getQualificationRecords();
        expect(response).toEqual({
            data: [
                {
                    createdAtTime: "2024-01-15T09:30:00Z",
                    createdBy: {
                        id: "id",
                        type: "driver",
                    },
                    expirationDate: "2024-01-15T09:30:00Z",
                    externalIds: {
                        externalIds: "externalIds",
                    },
                    fields: [
                        {
                            checkBoxesValue: {
                                value: ["value", "value"],
                                valueIds: ["valueIds", "valueIds"],
                            },
                            dateTimeValue: {
                                type: "datetime",
                                value: "2024-01-15T09:30:00Z",
                            },
                            id: "id",
                            label: "label",
                            mediaList: [
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            ],
                            multipleChoiceValue: {
                                value: "value",
                                valueId: "valueId",
                            },
                            numberValue: {
                                value: 1.1,
                            },
                            signatureValue: {
                                media: {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    {
                                        id: "id",
                                        label: "label",
                                        type: "text",
                                    },
                                    {
                                        id: "id",
                                        label: "label",
                                        type: "text",
                                    },
                                ],
                                rows: [
                                    {
                                        cells: [],
                                        id: "id",
                                    },
                                    {
                                        cells: [],
                                        id: "id",
                                    },
                                ],
                            },
                            textValue: {
                                value: "value",
                            },
                            type: "number",
                        },
                        {
                            checkBoxesValue: {
                                value: ["value", "value"],
                                valueIds: ["valueIds", "valueIds"],
                            },
                            dateTimeValue: {
                                type: "datetime",
                                value: "2024-01-15T09:30:00Z",
                            },
                            id: "id",
                            label: "label",
                            mediaList: [
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            ],
                            multipleChoiceValue: {
                                value: "value",
                                valueId: "valueId",
                            },
                            numberValue: {
                                value: 1.1,
                            },
                            signatureValue: {
                                media: {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    {
                                        id: "id",
                                        label: "label",
                                        type: "text",
                                    },
                                    {
                                        id: "id",
                                        label: "label",
                                        type: "text",
                                    },
                                ],
                                rows: [
                                    {
                                        cells: [],
                                        id: "id",
                                    },
                                    {
                                        cells: [],
                                        id: "id",
                                    },
                                ],
                            },
                            textValue: {
                                value: "value",
                            },
                            type: "number",
                        },
                    ],
                    id: "id",
                    issueDate: "2024-01-15T09:30:00Z",
                    owner: {
                        entityType: "worker",
                        externalIds: {
                            externalIds: "externalIds",
                        },
                        id: "id",
                    },
                    qualificationType: {
                        id: "id",
                        name: "name",
                        revisionId: "revisionId",
                    },
                    recordStatus: "active",
                    updatedAtTime: "2024-01-15T09:30:00Z",
                    updatedBy: {
                        id: "id",
                        type: "driver",
                    },
                },
                {
                    createdAtTime: "2024-01-15T09:30:00Z",
                    createdBy: {
                        id: "id",
                        type: "driver",
                    },
                    expirationDate: "2024-01-15T09:30:00Z",
                    externalIds: {
                        externalIds: "externalIds",
                    },
                    fields: [
                        {
                            checkBoxesValue: {
                                value: ["value", "value"],
                                valueIds: ["valueIds", "valueIds"],
                            },
                            dateTimeValue: {
                                type: "datetime",
                                value: "2024-01-15T09:30:00Z",
                            },
                            id: "id",
                            label: "label",
                            mediaList: [
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            ],
                            multipleChoiceValue: {
                                value: "value",
                                valueId: "valueId",
                            },
                            numberValue: {
                                value: 1.1,
                            },
                            signatureValue: {
                                media: {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    {
                                        id: "id",
                                        label: "label",
                                        type: "text",
                                    },
                                    {
                                        id: "id",
                                        label: "label",
                                        type: "text",
                                    },
                                ],
                                rows: [
                                    {
                                        cells: [],
                                        id: "id",
                                    },
                                    {
                                        cells: [],
                                        id: "id",
                                    },
                                ],
                            },
                            textValue: {
                                value: "value",
                            },
                            type: "number",
                        },
                        {
                            checkBoxesValue: {
                                value: ["value", "value"],
                                valueIds: ["valueIds", "valueIds"],
                            },
                            dateTimeValue: {
                                type: "datetime",
                                value: "2024-01-15T09:30:00Z",
                            },
                            id: "id",
                            label: "label",
                            mediaList: [
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                                {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            ],
                            multipleChoiceValue: {
                                value: "value",
                                valueId: "valueId",
                            },
                            numberValue: {
                                value: 1.1,
                            },
                            signatureValue: {
                                media: {
                                    id: "id",
                                    processingStatus: "unknown",
                                    url: "url",
                                    urlExpiresAt: "2024-01-15T09:30:00Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    {
                                        id: "id",
                                        label: "label",
                                        type: "text",
                                    },
                                    {
                                        id: "id",
                                        label: "label",
                                        type: "text",
                                    },
                                ],
                                rows: [
                                    {
                                        cells: [],
                                        id: "id",
                                    },
                                    {
                                        cells: [],
                                        id: "id",
                                    },
                                ],
                            },
                            textValue: {
                                value: "value",
                            },
                            type: "number",
                        },
                    ],
                    id: "id",
                    issueDate: "2024-01-15T09:30:00Z",
                    owner: {
                        entityType: "worker",
                        externalIds: {
                            externalIds: "externalIds",
                        },
                        id: "id",
                    },
                    qualificationType: {
                        id: "id",
                        name: "name",
                        revisionId: "revisionId",
                    },
                    recordStatus: "active",
                    updatedAtTime: "2024-01-15T09:30:00Z",
                    updatedBy: {
                        id: "id",
                        type: "driver",
                    },
                },
            ],
        });
    });

    test("getQualificationRecords (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getQualificationRecords (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getQualificationRecords (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getQualificationRecords (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getQualificationRecords (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getQualificationRecords (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getQualificationRecords (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getQualificationRecords (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getQualificationRecords (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecords();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("postQualificationRecord (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            fields: [{ id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7", type: "number" }],
            issueDate: "2025-08-27T10:20:30Z",
            owner: { entityType: "worker", id: "281474" },
            qualificationType: { id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7" },
        };
        const rawResponseBody = {
            data: {
                createdAtTime: "2019-06-13T19:08:25Z",
                createdBy: { id: "938172", type: "driver" },
                expirationDate: "2026-08-27T10:20:30Z",
                externalIds: { key: "value" },
                fields: [
                    {
                        checkBoxesValue: {
                            value: ["Option A", "Option B"],
                            valueIds: ["0cbbddb3-2541-4889-b4eb-92171cbfc142", "d33198cb-369f-4278-8120-d92d3ebf74bf"],
                        },
                        dateTimeValue: { type: "datetime", value: "2024-08-08T18:53:23Z" },
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        label: "License Number",
                        mediaList: [
                            {
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                processingStatus: "unknown",
                                url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                urlExpiresAt: "2019-06-13T19:08:25Z",
                            },
                        ],
                        multipleChoiceValue: { value: "Yes", valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc" },
                        numberValue: { value: 123.456 },
                        signatureValue: {
                            media: {
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                processingStatus: "unknown",
                                url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                urlExpiresAt: "2019-06-13T19:08:25Z",
                            },
                        },
                        tableValue: {
                            columns: [{ id: "id", label: "Store Number", type: "text" }],
                            rows: [
                                {
                                    cells: [
                                        {
                                            checkBoxesValue: {
                                                value: ["Option A", "Option B"],
                                                valueIds: [
                                                    "0cbbddb3-2541-4889-b4eb-92171cbfc142",
                                                    "d33198cb-369f-4278-8120-d92d3ebf74bf",
                                                ],
                                            },
                                            dateTimeValue: { type: "datetime", value: "2024-08-08T18:53:23Z" },
                                            id: "id",
                                            mediaValue: {
                                                mediaList: [
                                                    {
                                                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                        processingStatus: "unknown",
                                                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                        urlExpiresAt: "2019-06-13T19:08:25Z",
                                                    },
                                                ],
                                            },
                                            multipleChoiceValue: {
                                                value: "Yes",
                                                valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                                            },
                                            numberValue: { value: 123.456 },
                                            signatureValue: {
                                                media: {
                                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                    processingStatus: "unknown",
                                                    url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                    urlExpiresAt: "2019-06-13T19:08:25Z",
                                                },
                                            },
                                            textValue: { value: "Exposed wires" },
                                            type: "number",
                                        },
                                    ],
                                    id: "id",
                                },
                            ],
                        },
                        textValue: { value: "Exposed wires" },
                        type: "number",
                    },
                ],
                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                issueDate: "2025-08-27T10:20:30Z",
                owner: { entityType: "worker", externalIds: { key: "value" }, id: "281474" },
                qualificationType: {
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    name: "Driver License",
                    revisionId: "1214a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                },
                recordStatus: "active",
                updatedAtTime: "2019-06-13T19:08:25Z",
                updatedBy: { id: "938172", type: "driver" },
            },
        };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.postQualificationRecord({
            fields: [
                {
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    type: "number",
                },
            ],
            issueDate: "2025-08-27T10:20:30Z",
            owner: {
                entityType: "worker",
                id: "281474",
            },
            qualificationType: {
                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
            },
        });
        expect(response).toEqual({
            data: {
                createdAtTime: "2019-06-13T19:08:25Z",
                createdBy: {
                    id: "938172",
                    type: "driver",
                },
                expirationDate: "2026-08-27T10:20:30Z",
                externalIds: {
                    key: "value",
                },
                fields: [
                    {
                        checkBoxesValue: {
                            value: ["Option A", "Option B"],
                            valueIds: ["0cbbddb3-2541-4889-b4eb-92171cbfc142", "d33198cb-369f-4278-8120-d92d3ebf74bf"],
                        },
                        dateTimeValue: {
                            type: "datetime",
                            value: "2024-08-08T18:53:23Z",
                        },
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        label: "License Number",
                        mediaList: [
                            {
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                processingStatus: "unknown",
                                url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                urlExpiresAt: "2019-06-13T19:08:25Z",
                            },
                        ],
                        multipleChoiceValue: {
                            value: "Yes",
                            valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                        },
                        numberValue: {
                            value: 123.456,
                        },
                        signatureValue: {
                            media: {
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                processingStatus: "unknown",
                                url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                urlExpiresAt: "2019-06-13T19:08:25Z",
                            },
                        },
                        tableValue: {
                            columns: [
                                {
                                    id: "id",
                                    label: "Store Number",
                                    type: "text",
                                },
                            ],
                            rows: [
                                {
                                    cells: [
                                        {
                                            checkBoxesValue: {
                                                value: ["Option A", "Option B"],
                                                valueIds: [
                                                    "0cbbddb3-2541-4889-b4eb-92171cbfc142",
                                                    "d33198cb-369f-4278-8120-d92d3ebf74bf",
                                                ],
                                            },
                                            dateTimeValue: {
                                                type: "datetime",
                                                value: "2024-08-08T18:53:23Z",
                                            },
                                            id: "id",
                                            mediaValue: {
                                                mediaList: [
                                                    {
                                                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                        processingStatus: "unknown",
                                                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                        urlExpiresAt: "2019-06-13T19:08:25Z",
                                                    },
                                                ],
                                            },
                                            multipleChoiceValue: {
                                                value: "Yes",
                                                valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                                            },
                                            numberValue: {
                                                value: 123.456,
                                            },
                                            signatureValue: {
                                                media: {
                                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                    processingStatus: "unknown",
                                                    url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                    urlExpiresAt: "2019-06-13T19:08:25Z",
                                                },
                                            },
                                            textValue: {
                                                value: "Exposed wires",
                                            },
                                            type: "number",
                                        },
                                    ],
                                    id: "id",
                                },
                            ],
                        },
                        textValue: {
                            value: "Exposed wires",
                        },
                        type: "number",
                    },
                ],
                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                issueDate: "2025-08-27T10:20:30Z",
                owner: {
                    entityType: "worker",
                    externalIds: {
                        key: "value",
                    },
                    id: "281474",
                },
                qualificationType: {
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    name: "Driver License",
                    revisionId: "1214a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                },
                recordStatus: "active",
                updatedAtTime: "2019-06-13T19:08:25Z",
                updatedBy: {
                    id: "938172",
                    type: "driver",
                },
            },
        });
    });

    test("postQualificationRecord (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("postQualificationRecord (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("postQualificationRecord (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("postQualificationRecord (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("postQualificationRecord (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("postQualificationRecord (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("postQualificationRecord (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("postQualificationRecord (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("postQualificationRecord (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            issueDate: "2024-01-15T09:30:00Z",
            owner: { entityType: "worker", id: "id" },
            qualificationType: { id: "id" },
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postQualificationRecord({
                issueDate: "2024-01-15T09:30:00Z",
                owner: {
                    entityType: "worker",
                    id: "id",
                },
                qualificationType: {
                    id: "id",
                },
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("deleteQualificationRecord (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7" };

        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.betaApis.deleteQualificationRecord({
            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
        });
        expect(response).toEqual(undefined);
    });

    test("deleteQualificationRecord (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("deleteQualificationRecord (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("deleteQualificationRecord (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("deleteQualificationRecord (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("deleteQualificationRecord (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("deleteQualificationRecord (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("deleteQualificationRecord (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("deleteQualificationRecord (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("deleteQualificationRecord (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.deleteQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("patchQualificationRecord (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
            issueDate: "2025-08-27T10:20:30Z",
            owner: { entityType: "worker", id: "281474" },
        };
        const rawResponseBody = {
            data: {
                createdAtTime: "2019-06-13T19:08:25Z",
                createdBy: { id: "938172", type: "driver" },
                expirationDate: "2026-08-27T10:20:30Z",
                externalIds: { key: "value" },
                fields: [
                    {
                        checkBoxesValue: {
                            value: ["Option A", "Option B"],
                            valueIds: ["0cbbddb3-2541-4889-b4eb-92171cbfc142", "d33198cb-369f-4278-8120-d92d3ebf74bf"],
                        },
                        dateTimeValue: { type: "datetime", value: "2024-08-08T18:53:23Z" },
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        label: "License Number",
                        mediaList: [
                            {
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                processingStatus: "unknown",
                                url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                urlExpiresAt: "2019-06-13T19:08:25Z",
                            },
                        ],
                        multipleChoiceValue: { value: "Yes", valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc" },
                        numberValue: { value: 123.456 },
                        signatureValue: {
                            media: {
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                processingStatus: "unknown",
                                url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                urlExpiresAt: "2019-06-13T19:08:25Z",
                            },
                        },
                        tableValue: {
                            columns: [{ id: "id", label: "Store Number", type: "text" }],
                            rows: [
                                {
                                    cells: [
                                        {
                                            checkBoxesValue: {
                                                value: ["Option A", "Option B"],
                                                valueIds: [
                                                    "0cbbddb3-2541-4889-b4eb-92171cbfc142",
                                                    "d33198cb-369f-4278-8120-d92d3ebf74bf",
                                                ],
                                            },
                                            dateTimeValue: { type: "datetime", value: "2024-08-08T18:53:23Z" },
                                            id: "id",
                                            mediaValue: {
                                                mediaList: [
                                                    {
                                                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                        processingStatus: "unknown",
                                                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                        urlExpiresAt: "2019-06-13T19:08:25Z",
                                                    },
                                                ],
                                            },
                                            multipleChoiceValue: {
                                                value: "Yes",
                                                valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                                            },
                                            numberValue: { value: 123.456 },
                                            signatureValue: {
                                                media: {
                                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                    processingStatus: "unknown",
                                                    url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                    urlExpiresAt: "2019-06-13T19:08:25Z",
                                                },
                                            },
                                            textValue: { value: "Exposed wires" },
                                            type: "number",
                                        },
                                    ],
                                    id: "id",
                                },
                            ],
                        },
                        textValue: { value: "Exposed wires" },
                        type: "number",
                    },
                ],
                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                issueDate: "2025-08-27T10:20:30Z",
                owner: { entityType: "worker", externalIds: { key: "value" }, id: "281474" },
                qualificationType: {
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    name: "Driver License",
                    revisionId: "1214a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                },
                recordStatus: "active",
                updatedAtTime: "2019-06-13T19:08:25Z",
                updatedBy: { id: "938172", type: "driver" },
            },
        };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.patchQualificationRecord({
            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
            issueDate: "2025-08-27T10:20:30Z",
            owner: {
                entityType: "worker",
                id: "281474",
            },
        });
        expect(response).toEqual({
            data: {
                createdAtTime: "2019-06-13T19:08:25Z",
                createdBy: {
                    id: "938172",
                    type: "driver",
                },
                expirationDate: "2026-08-27T10:20:30Z",
                externalIds: {
                    key: "value",
                },
                fields: [
                    {
                        checkBoxesValue: {
                            value: ["Option A", "Option B"],
                            valueIds: ["0cbbddb3-2541-4889-b4eb-92171cbfc142", "d33198cb-369f-4278-8120-d92d3ebf74bf"],
                        },
                        dateTimeValue: {
                            type: "datetime",
                            value: "2024-08-08T18:53:23Z",
                        },
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        label: "License Number",
                        mediaList: [
                            {
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                processingStatus: "unknown",
                                url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                urlExpiresAt: "2019-06-13T19:08:25Z",
                            },
                        ],
                        multipleChoiceValue: {
                            value: "Yes",
                            valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                        },
                        numberValue: {
                            value: 123.456,
                        },
                        signatureValue: {
                            media: {
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                processingStatus: "unknown",
                                url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                urlExpiresAt: "2019-06-13T19:08:25Z",
                            },
                        },
                        tableValue: {
                            columns: [
                                {
                                    id: "id",
                                    label: "Store Number",
                                    type: "text",
                                },
                            ],
                            rows: [
                                {
                                    cells: [
                                        {
                                            checkBoxesValue: {
                                                value: ["Option A", "Option B"],
                                                valueIds: [
                                                    "0cbbddb3-2541-4889-b4eb-92171cbfc142",
                                                    "d33198cb-369f-4278-8120-d92d3ebf74bf",
                                                ],
                                            },
                                            dateTimeValue: {
                                                type: "datetime",
                                                value: "2024-08-08T18:53:23Z",
                                            },
                                            id: "id",
                                            mediaValue: {
                                                mediaList: [
                                                    {
                                                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                        processingStatus: "unknown",
                                                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                        urlExpiresAt: "2019-06-13T19:08:25Z",
                                                    },
                                                ],
                                            },
                                            multipleChoiceValue: {
                                                value: "Yes",
                                                valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                                            },
                                            numberValue: {
                                                value: 123.456,
                                            },
                                            signatureValue: {
                                                media: {
                                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                    processingStatus: "unknown",
                                                    url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                    urlExpiresAt: "2019-06-13T19:08:25Z",
                                                },
                                            },
                                            textValue: {
                                                value: "Exposed wires",
                                            },
                                            type: "number",
                                        },
                                    ],
                                    id: "id",
                                },
                            ],
                        },
                        textValue: {
                            value: "Exposed wires",
                        },
                        type: "number",
                    },
                ],
                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                issueDate: "2025-08-27T10:20:30Z",
                owner: {
                    entityType: "worker",
                    externalIds: {
                        key: "value",
                    },
                    id: "281474",
                },
                qualificationType: {
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    name: "Driver License",
                    revisionId: "1214a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                },
                recordStatus: "active",
                updatedAtTime: "2019-06-13T19:08:25Z",
                updatedBy: {
                    id: "938172",
                    type: "driver",
                },
            },
        });
    });

    test("patchQualificationRecord (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("patchQualificationRecord (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("patchQualificationRecord (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("patchQualificationRecord (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("patchQualificationRecord (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("patchQualificationRecord (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("patchQualificationRecord (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("patchQualificationRecord (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("patchQualificationRecord (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/qualification-records")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.patchQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("archiveQualificationRecord (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7" };

        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.betaApis.archiveQualificationRecord({
            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
        });
        expect(response).toEqual(undefined);
    });

    test("archiveQualificationRecord (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("archiveQualificationRecord (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("archiveQualificationRecord (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("archiveQualificationRecord (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("archiveQualificationRecord (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("archiveQualificationRecord (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("archiveQualificationRecord (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("archiveQualificationRecord (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("archiveQualificationRecord (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/archive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.archiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getQualificationRecordsStream (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    createdAtTime: "2019-06-13T19:08:25Z",
                    createdBy: { id: "938172", type: "driver" },
                    expirationDate: "2026-08-27T10:20:30Z",
                    externalIds: { key: "value" },
                    fields: [
                        {
                            checkBoxesValue: {
                                value: ["Option A", "Option B"],
                                valueIds: [
                                    "0cbbddb3-2541-4889-b4eb-92171cbfc142",
                                    "d33198cb-369f-4278-8120-d92d3ebf74bf",
                                ],
                            },
                            dateTimeValue: { type: "datetime", value: "2024-08-08T18:53:23Z" },
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            label: "License Number",
                            mediaList: [
                                {
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    processingStatus: "unknown",
                                    url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                    urlExpiresAt: "2019-06-13T19:08:25Z",
                                },
                            ],
                            multipleChoiceValue: { value: "Yes", valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc" },
                            numberValue: { value: 123.456 },
                            signatureValue: {
                                media: {
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    processingStatus: "unknown",
                                    url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                    urlExpiresAt: "2019-06-13T19:08:25Z",
                                },
                            },
                            tableValue: {
                                columns: [{ id: "id", label: "Store Number", type: "text" }],
                                rows: [
                                    {
                                        cells: [
                                            {
                                                checkBoxesValue: {
                                                    value: ["Option A", "Option B"],
                                                    valueIds: [
                                                        "0cbbddb3-2541-4889-b4eb-92171cbfc142",
                                                        "d33198cb-369f-4278-8120-d92d3ebf74bf",
                                                    ],
                                                },
                                                dateTimeValue: { type: "datetime", value: "2024-08-08T18:53:23Z" },
                                                id: "id",
                                                mediaValue: {
                                                    mediaList: [
                                                        {
                                                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                            processingStatus: "unknown",
                                                            url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                            urlExpiresAt: "2019-06-13T19:08:25Z",
                                                        },
                                                    ],
                                                },
                                                multipleChoiceValue: {
                                                    value: "Yes",
                                                    valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                                                },
                                                numberValue: { value: 123.456 },
                                                signatureValue: {
                                                    media: {
                                                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                        processingStatus: "unknown",
                                                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                        urlExpiresAt: "2019-06-13T19:08:25Z",
                                                    },
                                                },
                                                textValue: { value: "Exposed wires" },
                                                type: "number",
                                            },
                                        ],
                                        id: "id",
                                    },
                                ],
                            },
                            textValue: { value: "Exposed wires" },
                            type: "number",
                        },
                    ],
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    issueDate: "2025-08-27T10:20:30Z",
                    owner: { entityType: "worker", id: "281474" },
                    qualificationType: {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        name: "Driver License",
                        revisionId: "1214a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    },
                    recordStatus: "active",
                    updatedAtTime: "2019-06-13T19:08:25Z",
                    updatedBy: { id: "938172", type: "driver" },
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getQualificationRecordsStream({
            entityType: "worker",
            startTime: "2024-01-15T09:30:00Z",
        });
        expect(response).toEqual({
            data: [
                {
                    createdAtTime: "2019-06-13T19:08:25Z",
                    createdBy: {
                        id: "938172",
                        type: "driver",
                    },
                    expirationDate: "2026-08-27T10:20:30Z",
                    externalIds: {
                        key: "value",
                    },
                    fields: [
                        {
                            checkBoxesValue: {
                                value: ["Option A", "Option B"],
                                valueIds: [
                                    "0cbbddb3-2541-4889-b4eb-92171cbfc142",
                                    "d33198cb-369f-4278-8120-d92d3ebf74bf",
                                ],
                            },
                            dateTimeValue: {
                                type: "datetime",
                                value: "2024-08-08T18:53:23Z",
                            },
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            label: "License Number",
                            mediaList: [
                                {
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    processingStatus: "unknown",
                                    url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                    urlExpiresAt: "2019-06-13T19:08:25Z",
                                },
                            ],
                            multipleChoiceValue: {
                                value: "Yes",
                                valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                            },
                            numberValue: {
                                value: 123.456,
                            },
                            signatureValue: {
                                media: {
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    processingStatus: "unknown",
                                    url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                    urlExpiresAt: "2019-06-13T19:08:25Z",
                                },
                            },
                            tableValue: {
                                columns: [
                                    {
                                        id: "id",
                                        label: "Store Number",
                                        type: "text",
                                    },
                                ],
                                rows: [
                                    {
                                        cells: [
                                            {
                                                checkBoxesValue: {
                                                    value: ["Option A", "Option B"],
                                                    valueIds: [
                                                        "0cbbddb3-2541-4889-b4eb-92171cbfc142",
                                                        "d33198cb-369f-4278-8120-d92d3ebf74bf",
                                                    ],
                                                },
                                                dateTimeValue: {
                                                    type: "datetime",
                                                    value: "2024-08-08T18:53:23Z",
                                                },
                                                id: "id",
                                                mediaValue: {
                                                    mediaList: [
                                                        {
                                                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                            processingStatus: "unknown",
                                                            url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                            urlExpiresAt: "2019-06-13T19:08:25Z",
                                                        },
                                                    ],
                                                },
                                                multipleChoiceValue: {
                                                    value: "Yes",
                                                    valueId: "94096370-7228-4d83-ae5d-b20f3e45c0fc",
                                                },
                                                numberValue: {
                                                    value: 123.456,
                                                },
                                                signatureValue: {
                                                    media: {
                                                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                                        processingStatus: "unknown",
                                                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                                                        urlExpiresAt: "2019-06-13T19:08:25Z",
                                                    },
                                                },
                                                textValue: {
                                                    value: "Exposed wires",
                                                },
                                                type: "number",
                                            },
                                        ],
                                        id: "id",
                                    },
                                ],
                            },
                            textValue: {
                                value: "Exposed wires",
                            },
                            type: "number",
                        },
                    ],
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    issueDate: "2025-08-27T10:20:30Z",
                    owner: {
                        entityType: "worker",
                        id: "281474",
                    },
                    qualificationType: {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        name: "Driver License",
                        revisionId: "1214a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    },
                    recordStatus: "active",
                    updatedAtTime: "2019-06-13T19:08:25Z",
                    updatedBy: {
                        id: "938172",
                        type: "driver",
                    },
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getQualificationRecordsStream (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getQualificationRecordsStream (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getQualificationRecordsStream (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getQualificationRecordsStream (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getQualificationRecordsStream (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getQualificationRecordsStream (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getQualificationRecordsStream (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getQualificationRecordsStream (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getQualificationRecordsStream (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-records/stream")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationRecordsStream({
                entityType: "worker",
                startTime: "2024-01-15T09:30:00Z",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("unarchiveQualificationRecord (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7" };

        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.betaApis.unarchiveQualificationRecord({
            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
        });
        expect(response).toEqual(undefined);
    });

    test("unarchiveQualificationRecord (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("unarchiveQualificationRecord (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("unarchiveQualificationRecord (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("unarchiveQualificationRecord (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("unarchiveQualificationRecord (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("unarchiveQualificationRecord (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("unarchiveQualificationRecord (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("unarchiveQualificationRecord (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("unarchiveQualificationRecord (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/qualification-records/unarchive")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.unarchiveQualificationRecord({
                id: "id",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getQualificationTypes (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    createdAtTime: "2019-06-13T19:08:25Z",
                    createdBy: { id: "938172", type: "driver" },
                    entityType: "worker",
                    fields: [
                        {
                            allowManualEntry: true,
                            allowedAssetTypes: ["vehicle", "trailer"],
                            autofillFromId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            columns: [
                                {
                                    allowManualEntry: true,
                                    filterByRoleIds: ["23d4d8d3-dc10-4e7a-a183-69968751f23e"],
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    includeDrivers: true,
                                    includeUsers: true,
                                    label: "Engine Hours",
                                    numDecimalPlaces: 2,
                                    options: [
                                        {
                                            id: "e879028d-bce5-0238-ffec-11cd9236bcda",
                                            ignoreQuestionFromScoreIfSelected: false,
                                            label: "Yes",
                                            optionScoreWeight: 5,
                                        },
                                    ],
                                    type: "number",
                                },
                            ],
                            filterByRoleIds: ["23d4d8d3-dc10-4e7a-a183-69968751f23e"],
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            includeDrivers: true,
                            includeUsers: true,
                            isAutofillSource: true,
                            isRequired: true,
                            label: "Engine Hours",
                            numDecimalPlaces: 2,
                            options: [
                                {
                                    id: "e879028d-bce5-0238-ffec-11cd9236bcda",
                                    ignoreQuestionFromScoreIfSelected: false,
                                    label: "Yes",
                                    optionScoreWeight: 5,
                                },
                            ],
                            questionWeight: 5,
                            type: "number",
                        },
                    ],
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    name: "Driver License",
                    revisionId: "1214a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    updatedAtTime: "2019-06-13T19:08:25Z",
                    updatedBy: { id: "938172", type: "driver" },
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getQualificationTypes({
            entityType: "worker",
        });
        expect(response).toEqual({
            data: [
                {
                    createdAtTime: "2019-06-13T19:08:25Z",
                    createdBy: {
                        id: "938172",
                        type: "driver",
                    },
                    entityType: "worker",
                    fields: [
                        {
                            allowManualEntry: true,
                            allowedAssetTypes: ["vehicle", "trailer"],
                            autofillFromId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            columns: [
                                {
                                    allowManualEntry: true,
                                    filterByRoleIds: ["23d4d8d3-dc10-4e7a-a183-69968751f23e"],
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    includeDrivers: true,
                                    includeUsers: true,
                                    label: "Engine Hours",
                                    numDecimalPlaces: 2,
                                    options: [
                                        {
                                            id: "e879028d-bce5-0238-ffec-11cd9236bcda",
                                            ignoreQuestionFromScoreIfSelected: false,
                                            label: "Yes",
                                            optionScoreWeight: 5,
                                        },
                                    ],
                                    type: "number",
                                },
                            ],
                            filterByRoleIds: ["23d4d8d3-dc10-4e7a-a183-69968751f23e"],
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            includeDrivers: true,
                            includeUsers: true,
                            isAutofillSource: true,
                            isRequired: true,
                            label: "Engine Hours",
                            numDecimalPlaces: 2,
                            options: [
                                {
                                    id: "e879028d-bce5-0238-ffec-11cd9236bcda",
                                    ignoreQuestionFromScoreIfSelected: false,
                                    label: "Yes",
                                    optionScoreWeight: 5,
                                },
                            ],
                            questionWeight: 5,
                            type: "number",
                        },
                    ],
                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    name: "Driver License",
                    revisionId: "1214a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                    updatedAtTime: "2019-06-13T19:08:25Z",
                    updatedBy: {
                        id: "938172",
                        type: "driver",
                    },
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getQualificationTypes (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getQualificationTypes (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getQualificationTypes (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getQualificationTypes (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getQualificationTypes (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getQualificationTypes (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getQualificationTypes (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getQualificationTypes (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getQualificationTypes (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/qualification-types")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getQualificationTypes({
                entityType: "worker",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("postReadings (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "123451234512345",
                    entityType: "asset",
                    happenedAtTime: "2023-10-27T10:00:00Z",
                    readingId: "airInletPressure",
                    value: { key: "value" },
                },
            ],
        };

        server.mockEndpoint().post("/readings").jsonBody(rawRequestBody).respondWith().statusCode(200).build();

        const response = await client.betaApis.postReadings({
            data: [
                {
                    entityId: "123451234512345",
                    entityType: "asset",
                    happenedAtTime: "2023-10-27T10:00:00Z",
                    readingId: "airInletPressure",
                    value: {
                        key: "value",
                    },
                },
            ],
        });
        expect(response).toEqual(undefined);
    });

    test("postReadings (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("postReadings (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("postReadings (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("postReadings (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("postReadings (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("postReadings (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("postReadings (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("postReadings (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("postReadings (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            data: [
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
                {
                    entityId: "entityId",
                    entityType: "asset",
                    happenedAtTime: "happenedAtTime",
                    readingId: "readingId",
                    value: { value: { key: "value" } },
                },
            ],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/readings")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.postReadings({
                data: [
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                    {
                        entityId: "entityId",
                        entityType: "asset",
                        happenedAtTime: "happenedAtTime",
                        readingId: "readingId",
                        value: {
                            value: {
                                key: "value",
                            },
                        },
                    },
                ],
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("listReadingsDefinitions (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    category: "smartTrailer",
                    description: "Engine Speed",
                    entityType: "sensor",
                    enumValues: [{ label: "Critically High", symbol: "criticallyHigh" }],
                    ingestionEnabled: true,
                    label: "engineRpm",
                    readingId: "12345",
                    type: { key: "value" },
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.listReadingsDefinitions();
        expect(response).toEqual({
            data: [
                {
                    category: "smartTrailer",
                    description: "Engine Speed",
                    entityType: "sensor",
                    enumValues: [
                        {
                            label: "Critically High",
                            symbol: "criticallyHigh",
                        },
                    ],
                    ingestionEnabled: true,
                    label: "engineRpm",
                    readingId: "12345",
                    type: {
                        key: "value",
                    },
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("listReadingsDefinitions (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("listReadingsDefinitions (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("listReadingsDefinitions (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("listReadingsDefinitions (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("listReadingsDefinitions (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("listReadingsDefinitions (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("listReadingsDefinitions (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("listReadingsDefinitions (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("listReadingsDefinitions (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/readings/definitions")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.listReadingsDefinitions();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getReadingsHistory (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    entityId: "123456",
                    externalIds: { key: "value" },
                    happenedAtTime: "2020-01-27T07:06:25Z",
                    value: { key: "value" },
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.betaApis.getReadingsHistory({
            readingId: "readingId",
            entityType: "entityType",
        });
        expect(response).toEqual({
            data: [
                {
                    entityId: "123456",
                    externalIds: {
                        key: "value",
                    },
                    happenedAtTime: "2020-01-27T07:06:25Z",
                    value: {
                        key: "value",
                    },
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getReadingsHistory (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getReadingsHistory (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getReadingsHistory (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(405).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getReadingsHistory (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getReadingsHistory (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getReadingsHistory (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(501).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getReadingsHistory (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(502).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getReadingsHistory (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(503).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getReadingsHistory (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/history").respondWith().statusCode(504).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsHistory({
                readingId: "readingId",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getReadingsSnapshot (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    entityId: "123456",
                    externalIds: { key: "value" },
                    happenedAtTime: "2020-01-27T07:06:25Z",
                    readingId: "engineSpeed",
                    value: { key: "value" },
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.betaApis.getReadingsSnapshot({
            readingIds: "readingIds",
            entityType: "entityType",
        });
        expect(response).toEqual({
            data: [
                {
                    entityId: "123456",
                    externalIds: {
                        key: "value",
                    },
                    happenedAtTime: "2020-01-27T07:06:25Z",
                    readingId: "engineSpeed",
                    value: {
                        key: "value",
                    },
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getReadingsSnapshot (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getReadingsSnapshot (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getReadingsSnapshot (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(405).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getReadingsSnapshot (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getReadingsSnapshot (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getReadingsSnapshot (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(501).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getReadingsSnapshot (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(502).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getReadingsSnapshot (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(503).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getReadingsSnapshot (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/readings/latest").respondWith().statusCode(504).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReadingsSnapshot({
                readingIds: "readingIds",
                entityType: "entityType",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getReportConfigs (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    columns: [{ dataType: "string", name: "Asset: Id" }],
                    datasetId: "Assets",
                    filters: {
                        primaryTimeRange: { endTime: "2019-06-13T21:08:25Z", startTime: "2019-06-13T19:08:25Z" },
                    },
                    id: "4f71fd67-54f0-41de-991c-ee1e031134d1",
                    name: "Asset Report",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.betaApis.getReportConfigs();
        expect(response).toEqual({
            data: [
                {
                    columns: [
                        {
                            dataType: "string",
                            name: "Asset: Id",
                        },
                    ],
                    datasetId: "Assets",
                    filters: {
                        primaryTimeRange: {
                            endTime: "2019-06-13T21:08:25Z",
                            startTime: "2019-06-13T19:08:25Z",
                        },
                    },
                    id: "4f71fd67-54f0-41de-991c-ee1e031134d1",
                    name: "Asset Report",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getReportConfigs (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getReportConfigs (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getReportConfigs (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(405).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getReportConfigs (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getReportConfigs (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getReportConfigs (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(501).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getReportConfigs (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(502).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getReportConfigs (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(503).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getReportConfigs (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/configs").respondWith().statusCode(504).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportConfigs();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getDatasets (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    displayName: "Assets",
                    fields: [{ dataType: "string", displayName: "Asset: Name", name: "Name" }],
                    hasTimeRangeFilter: true,
                    id: "Assets",
                    timeRangeLimitDays: 31,
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.betaApis.getDatasets();
        expect(response).toEqual({
            data: [
                {
                    displayName: "Assets",
                    fields: [
                        {
                            dataType: "string",
                            displayName: "Asset: Name",
                            name: "Name",
                        },
                    ],
                    hasTimeRangeFilter: true,
                    id: "Assets",
                    timeRangeLimitDays: 31,
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getDatasets (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getDatasets (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getDatasets (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(405).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getDatasets (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getDatasets (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getDatasets (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(501).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getDatasets (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(502).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getDatasets (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(503).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getDatasets (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/datasets").respondWith().statusCode(504).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getDatasets();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getReportRuns (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    createdAtTime: "2019-06-13T19:08:25Z",
                    id: "4f71fd67-54f0-41de-991c-ee1e031134d1",
                    status: "complete",
                    updatedAtTime: "2019-06-13T19:08:25Z",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.betaApis.getReportRuns();
        expect(response).toEqual({
            data: [
                {
                    createdAtTime: "2019-06-13T19:08:25Z",
                    id: "4f71fd67-54f0-41de-991c-ee1e031134d1",
                    status: "complete",
                    updatedAtTime: "2019-06-13T19:08:25Z",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getReportRuns (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getReportRuns (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getReportRuns (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(405).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getReportRuns (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getReportRuns (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getReportRuns (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(501).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getReportRuns (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(502).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getReportRuns (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(503).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getReportRuns (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs").respondWith().statusCode(504).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRuns();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("createReportRun (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = {
            data: {
                createdAtTime: "2019-06-13T19:08:25Z",
                id: "4f71fd67-54f0-41de-991c-ee1e031134d1",
                status: "complete",
                updatedAtTime: "2019-06-13T19:08:25Z",
            },
        };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.createReportRun({
            reportConfig: {},
        });
        expect(response).toEqual({
            data: {
                createdAtTime: "2019-06-13T19:08:25Z",
                id: "4f71fd67-54f0-41de-991c-ee1e031134d1",
                status: "complete",
                updatedAtTime: "2019-06-13T19:08:25Z",
            },
        });
    });

    test("createReportRun (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("createReportRun (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("createReportRun (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("createReportRun (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("createReportRun (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("createReportRun (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("createReportRun (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("createReportRun (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("createReportRun (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { reportConfig: {} };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/reports/runs")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.createReportRun({
                reportConfig: {},
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getReportRunData (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: {
                columns: [{ dataType: "string", name: "Device Name" }],
                rows: [
                    [{ key: "value" }, { key: "value" }, { key: "value" }, { key: "value" }],
                    [{ key: "value" }, { key: "value" }, { key: "value" }, { key: "value" }],
                    [{ key: "value" }, { key: "value" }, { key: "value" }],
                    [{ key: "value" }, { key: "value" }, { key: "value" }],
                ],
                status: "complete",
            },
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.betaApis.getReportRunData({
            id: "id",
        });
        expect(response).toEqual({
            data: {
                columns: [
                    {
                        dataType: "string",
                        name: "Device Name",
                    },
                ],
                rows: [
                    [
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                    ],
                    [
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                    ],
                    [
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                    ],
                    [
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                        {
                            key: "value",
                        },
                    ],
                ],
                status: "complete",
            },
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getReportRunData (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getReportRunData (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getReportRunData (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(405).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getReportRunData (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getReportRunData (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getReportRunData (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(501).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getReportRunData (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(502).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getReportRunData (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(503).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getReportRunData (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/reports/runs/data").respondWith().statusCode(504).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.betaApis.getReportRunData({
                id: "id",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getDriverSafetyScores (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    behaviors: [{ behaviorType: "acceleration", count: 5, scoreImpact: -18.91020325321117 }],
                    driveDistanceMeters: 2207296,
                    driveTimeMilliseconds: 136997730,
                    driverId: "1234",
                    driverScore: 92,
                    speeding: [
                        { durationMilliseconds: 178773, scoreImpact: -0.13049340306587562, speedingType: "light" },
                    ],
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getDriverSafetyScores({
            endTime: "endTime",
            startTime: "startTime",
        });
        expect(response).toEqual({
            data: [
                {
                    behaviors: [
                        {
                            behaviorType: "acceleration",
                            count: 5,
                            scoreImpact: -18.91020325321117,
                        },
                    ],
                    driveDistanceMeters: 2207296,
                    driveTimeMilliseconds: 136997730,
                    driverId: "1234",
                    driverScore: 92,
                    speeding: [
                        {
                            durationMilliseconds: 178773,
                            scoreImpact: -0.13049340306587562,
                            speedingType: "light",
                        },
                    ],
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getDriverSafetyScores (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getDriverSafetyScores (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getDriverSafetyScores (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getDriverSafetyScores (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getDriverSafetyScores (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getDriverSafetyScores (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getDriverSafetyScores (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getDriverSafetyScores (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getDriverSafetyScores (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getDriverSafetyScoreTrips (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    behaviors: [
                        { behaviorType: "acceleration", count: 1000000, scoreImpact: 1.1 },
                        { behaviorType: "acceleration", count: 1000000, scoreImpact: 1.1 },
                    ],
                    driveDistanceMeters: 1000000,
                    driverId: "driverId",
                    speeding: [
                        { durationMilliseconds: 1000000, scoreImpact: 1.1, speedingType: "light" },
                        { durationMilliseconds: 1000000, scoreImpact: 1.1, speedingType: "light" },
                    ],
                    tripEndTime: "tripEndTime",
                    tripScoreImpact: 1.1,
                    tripStartTime: "tripStartTime",
                    vehicleId: "vehicleId",
                },
                {
                    behaviors: [
                        { behaviorType: "acceleration", count: 1000000, scoreImpact: 1.1 },
                        { behaviorType: "acceleration", count: 1000000, scoreImpact: 1.1 },
                    ],
                    driveDistanceMeters: 1000000,
                    driverId: "driverId",
                    speeding: [
                        { durationMilliseconds: 1000000, scoreImpact: 1.1, speedingType: "light" },
                        { durationMilliseconds: 1000000, scoreImpact: 1.1, speedingType: "light" },
                    ],
                    tripEndTime: "tripEndTime",
                    tripScoreImpact: 1.1,
                    tripStartTime: "tripStartTime",
                    vehicleId: "vehicleId",
                },
            ],
            pagination: { endCursor: "endCursor", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getDriverSafetyScoreTrips({
            endTime: "endTime",
            startTime: "startTime",
        });
        expect(response).toEqual({
            data: [
                {
                    behaviors: [
                        {
                            behaviorType: "acceleration",
                            count: 1000000,
                            scoreImpact: 1.1,
                        },
                        {
                            behaviorType: "acceleration",
                            count: 1000000,
                            scoreImpact: 1.1,
                        },
                    ],
                    driveDistanceMeters: 1000000,
                    driverId: "driverId",
                    speeding: [
                        {
                            durationMilliseconds: 1000000,
                            scoreImpact: 1.1,
                            speedingType: "light",
                        },
                        {
                            durationMilliseconds: 1000000,
                            scoreImpact: 1.1,
                            speedingType: "light",
                        },
                    ],
                    tripEndTime: "tripEndTime",
                    tripScoreImpact: 1.1,
                    tripStartTime: "tripStartTime",
                    vehicleId: "vehicleId",
                },
                {
                    behaviors: [
                        {
                            behaviorType: "acceleration",
                            count: 1000000,
                            scoreImpact: 1.1,
                        },
                        {
                            behaviorType: "acceleration",
                            count: 1000000,
                            scoreImpact: 1.1,
                        },
                    ],
                    driveDistanceMeters: 1000000,
                    driverId: "driverId",
                    speeding: [
                        {
                            durationMilliseconds: 1000000,
                            scoreImpact: 1.1,
                            speedingType: "light",
                        },
                        {
                            durationMilliseconds: 1000000,
                            scoreImpact: 1.1,
                            speedingType: "light",
                        },
                    ],
                    tripEndTime: "tripEndTime",
                    tripScoreImpact: 1.1,
                    tripStartTime: "tripStartTime",
                    vehicleId: "vehicleId",
                },
            ],
            pagination: {
                endCursor: "endCursor",
                hasNextPage: true,
            },
        });
    });

    test("getDriverSafetyScoreTrips (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getDriverSafetyScoreTrips (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getDriverSafetyScoreTrips (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getDriverSafetyScoreTrips (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getDriverSafetyScoreTrips (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getDriverSafetyScoreTrips (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getDriverSafetyScoreTrips (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getDriverSafetyScoreTrips (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getDriverSafetyScoreTrips (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/drivers/trips")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getDriverSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getTagGroupSafetyScores (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: {
                behaviors: [{ behaviorType: "acceleration", count: 5, scoreImpact: -18.91020325321117 }],
                combinedScore: 92,
                driveDistanceMeters: 2207296,
                driveTimeMilliseconds: 136997730,
                speeding: [{ durationMilliseconds: 178773, scoreImpact: -0.13049340306587562, speedingType: "light" }],
            },
        };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getTagGroupSafetyScores({
            endTime: "endTime",
            startTime: "startTime",
            scoreType: "driver",
        });
        expect(response).toEqual({
            data: {
                behaviors: [
                    {
                        behaviorType: "acceleration",
                        count: 5,
                        scoreImpact: -18.91020325321117,
                    },
                ],
                combinedScore: 92,
                driveDistanceMeters: 2207296,
                driveTimeMilliseconds: 136997730,
                speeding: [
                    {
                        durationMilliseconds: 178773,
                        scoreImpact: -0.13049340306587562,
                        speedingType: "light",
                    },
                ],
            },
        });
    });

    test("getTagGroupSafetyScores (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getTagGroupSafetyScores (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getTagGroupSafetyScores (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getTagGroupSafetyScores (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getTagGroupSafetyScores (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getTagGroupSafetyScores (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getTagGroupSafetyScores (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getTagGroupSafetyScores (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getTagGroupSafetyScores (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tag-group")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagGroupSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getTagSafetyScores (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    behaviors: [{ behaviorType: "acceleration", count: 5, scoreImpact: -18.91020325321117 }],
                    driveDistanceMeters: 2207296,
                    driveTimeMilliseconds: 136997730,
                    speeding: [
                        { durationMilliseconds: 178773, scoreImpact: -0.13049340306587562, speedingType: "light" },
                    ],
                    tagId: "5678",
                    tagScore: 92,
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getTagSafetyScores({
            endTime: "endTime",
            startTime: "startTime",
            scoreType: "driver",
        });
        expect(response).toEqual({
            data: [
                {
                    behaviors: [
                        {
                            behaviorType: "acceleration",
                            count: 5,
                            scoreImpact: -18.91020325321117,
                        },
                    ],
                    driveDistanceMeters: 2207296,
                    driveTimeMilliseconds: 136997730,
                    speeding: [
                        {
                            durationMilliseconds: 178773,
                            scoreImpact: -0.13049340306587562,
                            speedingType: "light",
                        },
                    ],
                    tagId: "5678",
                    tagScore: 92,
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getTagSafetyScores (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getTagSafetyScores (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getTagSafetyScores (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getTagSafetyScores (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getTagSafetyScores (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getTagSafetyScores (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getTagSafetyScores (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getTagSafetyScores (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getTagSafetyScores (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/tags")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getTagSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
                scoreType: "driver",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getVehicleSafetyScores (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    behaviors: [{ behaviorType: "acceleration", count: 5, scoreImpact: -18.91020325321117 }],
                    driveDistanceMeters: 2207296,
                    driveTimeMilliseconds: 136997730,
                    speeding: [
                        { durationMilliseconds: 178773, scoreImpact: -0.13049340306587562, speedingType: "light" },
                    ],
                    vehicleId: "5678",
                    vehicleScore: 92,
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getVehicleSafetyScores({
            endTime: "endTime",
            startTime: "startTime",
        });
        expect(response).toEqual({
            data: [
                {
                    behaviors: [
                        {
                            behaviorType: "acceleration",
                            count: 5,
                            scoreImpact: -18.91020325321117,
                        },
                    ],
                    driveDistanceMeters: 2207296,
                    driveTimeMilliseconds: 136997730,
                    speeding: [
                        {
                            durationMilliseconds: 178773,
                            scoreImpact: -0.13049340306587562,
                            speedingType: "light",
                        },
                    ],
                    vehicleId: "5678",
                    vehicleScore: 92,
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getVehicleSafetyScores (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getVehicleSafetyScores (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getVehicleSafetyScores (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getVehicleSafetyScores (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getVehicleSafetyScores (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getVehicleSafetyScores (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getVehicleSafetyScores (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getVehicleSafetyScores (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getVehicleSafetyScores (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScores({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getVehicleSafetyScoreTrips (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    behaviors: [
                        { behaviorType: "acceleration", count: 1000000, scoreImpact: 1.1 },
                        { behaviorType: "acceleration", count: 1000000, scoreImpact: 1.1 },
                    ],
                    driveDistanceMeters: 1000000,
                    driverId: "driverId",
                    speeding: [
                        { durationMilliseconds: 1000000, scoreImpact: 1.1, speedingType: "light" },
                        { durationMilliseconds: 1000000, scoreImpact: 1.1, speedingType: "light" },
                    ],
                    tripEndTime: "tripEndTime",
                    tripScoreImpact: 1.1,
                    tripStartTime: "tripStartTime",
                    vehicleId: "vehicleId",
                },
                {
                    behaviors: [
                        { behaviorType: "acceleration", count: 1000000, scoreImpact: 1.1 },
                        { behaviorType: "acceleration", count: 1000000, scoreImpact: 1.1 },
                    ],
                    driveDistanceMeters: 1000000,
                    driverId: "driverId",
                    speeding: [
                        { durationMilliseconds: 1000000, scoreImpact: 1.1, speedingType: "light" },
                        { durationMilliseconds: 1000000, scoreImpact: 1.1, speedingType: "light" },
                    ],
                    tripEndTime: "tripEndTime",
                    tripScoreImpact: 1.1,
                    tripStartTime: "tripStartTime",
                    vehicleId: "vehicleId",
                },
            ],
            pagination: { endCursor: "endCursor", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.betaApis.getVehicleSafetyScoreTrips({
            endTime: "endTime",
            startTime: "startTime",
        });
        expect(response).toEqual({
            data: [
                {
                    behaviors: [
                        {
                            behaviorType: "acceleration",
                            count: 1000000,
                            scoreImpact: 1.1,
                        },
                        {
                            behaviorType: "acceleration",
                            count: 1000000,
                            scoreImpact: 1.1,
                        },
                    ],
                    driveDistanceMeters: 1000000,
                    driverId: "driverId",
                    speeding: [
                        {
                            durationMilliseconds: 1000000,
                            scoreImpact: 1.1,
                            speedingType: "light",
                        },
                        {
                            durationMilliseconds: 1000000,
                            scoreImpact: 1.1,
                            speedingType: "light",
                        },
                    ],
                    tripEndTime: "tripEndTime",
                    tripScoreImpact: 1.1,
                    tripStartTime: "tripStartTime",
                    vehicleId: "vehicleId",
                },
                {
                    behaviors: [
                        {
                            behaviorType: "acceleration",
                            count: 1000000,
                            scoreImpact: 1.1,
                        },
                        {
                            behaviorType: "acceleration",
                            count: 1000000,
                            scoreImpact: 1.1,
                        },
                    ],
                    driveDistanceMeters: 1000000,
                    driverId: "driverId",
                    speeding: [
                        {
                            durationMilliseconds: 1000000,
                            scoreImpact: 1.1,
                            speedingType: "light",
                        },
                        {
                            durationMilliseconds: 1000000,
                            scoreImpact: 1.1,
                            speedingType: "light",
                        },
                    ],
                    tripEndTime: "tripEndTime",
                    tripScoreImpact: 1.1,
                    tripStartTime: "tripStartTime",
                    vehicleId: "vehicleId",
                },
            ],
            pagination: {
                endCursor: "endCursor",
                hasNextPage: true,
            },
        });
    });

    test("getVehicleSafetyScoreTrips (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getVehicleSafetyScoreTrips (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getVehicleSafetyScoreTrips (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getVehicleSafetyScoreTrips (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getVehicleSafetyScoreTrips (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getVehicleSafetyScoreTrips (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getVehicleSafetyScoreTrips (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getVehicleSafetyScoreTrips (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getVehicleSafetyScoreTrips (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/safety-scores/vehicles/trips")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.betaApis.getVehicleSafetyScoreTrips({
                endTime: "endTime",
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });
});
