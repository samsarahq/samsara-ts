// This file was auto-generated by Fern from our API Definition.

export interface V1VisionStepResultsItem {
    angleCheck?: V1VisionStepResultsItem.AngleCheck;
    barcode?: V1VisionStepResultsItem.Barcode.Item[];
    booleanLogic?: V1VisionStepResultsItem.BooleanLogic;
    caliper?: V1VisionStepResultsItem.Caliper;
    contour?: V1VisionStepResultsItem.Contour;
    distance?: V1VisionStepResultsItem.Distance;
    expirationDate?: V1VisionStepResultsItem.ExpirationDate;
    findCopies?: V1VisionStepResultsItem.FindCopies;
    findEdge?: V1VisionStepResultsItem.FindEdge;
    findShapes?: V1VisionStepResultsItem.FindShapes;
    fixture?: V1VisionStepResultsItem.Fixture;
    labelMatch?: V1VisionStepResultsItem.LabelMatch;
    name?: string;
    presenceAbsence?: V1VisionStepResultsItem.PresenceAbsence;
    result?: string;
    textMatch?: V1VisionStepResultsItem.TextMatch;
}

export namespace V1VisionStepResultsItem {
    export interface AngleCheck {
        /** The configured angle allowance range (in degrees) */
        angleConfigured?: AngleCheck.AngleConfigured;
        /** The counter-clockwise angle detected from the first edge to the second edge */
        angleFound?: number;
        /** The name of the second reference step used to check the angle */
        endStepName?: string;
        /** The name of the first reference step used to check the angle */
        startStepName?: string;
    }

    export namespace AngleCheck {
        /**
         * The configured angle allowance range (in degrees)
         */
        export interface AngleConfigured {
            high?: number;
            low?: number;
        }
    }

    export type Barcode = Barcode.Item[];

    export namespace Barcode {
        export interface Item {
            contents?: string;
            matchString?: string;
            type?: string;
        }
    }

    export interface BooleanLogic {
        operator?: string;
        steps?: BooleanLogic.Steps.Item[];
    }

    export namespace BooleanLogic {
        export type Steps = Steps.Item[];

        export namespace Steps {
            export interface Item {
                name?: string;
                result?: string;
            }
        }
    }

    export interface Caliper {
        /** The configured angle allowance range */
        angleRange?: Caliper.AngleRange;
        /** The configured contrast allowance range */
        contrastRange?: Caliper.ContrastRange;
        /** The distance found between the found edges */
        distanceFound?: number;
        /** The configured polarity for finding edges. Valid values: `LIGHT TO DARK`, `DARK TO LIGHT`. */
        filterPolarity?: Caliper.FilterPolarity;
        /** The maximum allowed distance threshold */
        maxDistance?: number;
        /** The minumum allowed distance threshold */
        minDistance?: number;
        /** The configured sharpness allowance range */
        sharpnessRange?: Caliper.SharpnessRange;
        /** The configured straightness allowance range */
        straightnessRange?: Caliper.StraightnessRange;
        /** The measurement unit of the distance found and the min and max distance threshold */
        unit?: string;
    }

    export namespace Caliper {
        /**
         * The configured angle allowance range
         */
        export interface AngleRange {
            high?: number;
            low?: number;
        }

        /**
         * The configured contrast allowance range
         */
        export interface ContrastRange {
            high?: number;
            low?: number;
        }

        /** The configured polarity for finding edges. Valid values: `LIGHT TO DARK`, `DARK TO LIGHT`. */
        export const FilterPolarity = {
            LightToDark: "LIGHT TO DARK",
            DarkToLight: "DARK TO LIGHT",
        } as const;
        export type FilterPolarity = (typeof FilterPolarity)[keyof typeof FilterPolarity];

        /**
         * The configured sharpness allowance range
         */
        export interface SharpnessRange {
            high?: number;
            low?: number;
        }

        /**
         * The configured straightness allowance range
         */
        export interface StraightnessRange {
            high?: number;
            low?: number;
        }
    }

    export interface Contour {
        /** The rotation angle found */
        angleDegrees?: number;
        /** The rotation angle allowance */
        angleTolerance?: number;
        /** The contour match percentage with the configured contour */
        matchPercentage?: number;
        /** The configured match threshold for contours */
        matchThreshold?: number;
    }

    export interface Distance {
        /** The distance found between the start and end references */
        distanceFound?: number;
        /** The name of the second reference step that we're checking the distances between */
        endStepName?: string;
        /** Whether an offset angle range is enforced */
        enforceOffsetAngleRange?: boolean;
        /** The maximum allowed distance threshold */
        maxDistance?: number;
        /** The maximum angle allowance (in degrees) if enforceOffsetAngleRange is true */
        maxOffsetAngle?: number;
        /** The minumum allowed distance threshold */
        minDistance?: number;
        /** The minimum angle allowance (in degrees) if enforceOffsetAngleRange is true */
        minOffsetAngle?: number;
        /** The counter-clockwise angle (in degrees) found between the horizontal axis of the start reference step and the last */
        offsetAngleFound?: number;
        /** The name of the first reference step that we're checking the distances between */
        startStepName?: string;
        /** The measurement unit of the distance found and the min and max distance threshold */
        unit?: string;
    }

    export interface ExpirationDate {
        dateOffset?: number;
        foundDate?: string;
        matchDate?: string;
    }

    export interface FindCopies {
        /** The orientation angle tolerance (+/- Â°) */
        angleTolerance?: number;
        /** The number of copies found */
        foundCount?: number;
        /** The maximum number of copies allowed */
        maxCount?: number;
        /** The minimum number of copies allowed */
        minCount?: number;
        /** The minimum required similarity (in %) of a found copy compared to the configured match region */
        threshold?: number;
    }

    export interface FindEdge {
        /** The detected angle in degrees */
        angleFound?: number;
        /** The configured angle allowance range */
        angleRange?: FindEdge.AngleRange;
        /** The detected contrast percentage */
        contrastPercent?: number;
        /** The configured contrast allowance range */
        contrastRange?: FindEdge.ContrastRange;
        /** The configured polarity for finding edges. Valid values: `LIGHT TO DARK`, `DARK TO LIGHT`. */
        filterPolarity?: string;
        /** The detected sharpness percentage */
        sharpnessPercent?: number;
        /** The configured sharpness allowance range */
        sharpnessRange?: FindEdge.SharpnessRange;
        /** The detected straightness percentage */
        straightnessFound?: number;
        /** The configured straightness allowance range */
        straightnessRange?: FindEdge.StraightnessRange;
    }

    export namespace FindEdge {
        /**
         * The configured angle allowance range
         */
        export interface AngleRange {
            high?: number;
            low?: number;
        }

        /**
         * The configured contrast allowance range
         */
        export interface ContrastRange {
            high?: number;
            low?: number;
        }

        /**
         * The configured sharpness allowance range
         */
        export interface SharpnessRange {
            high?: number;
            low?: number;
        }

        /**
         * The configured straightness allowance range
         */
        export interface StraightnessRange {
            high?: number;
            low?: number;
        }
    }

    export interface FindShapes {
        foundCount?: number;
        maxCount?: number;
        minCount?: number;
    }

    export interface Fixture {
        coordinates?: Fixture.Coordinates;
        found?: boolean;
        rotationDegrees?: number;
    }

    export namespace Fixture {
        export interface Coordinates {
            x?: number;
            y?: number;
        }
    }

    export interface LabelMatch {
        score?: number;
        threshold?: number;
    }

    export interface PresenceAbsence {
        blueRange?: PresenceAbsence.BlueRange;
        checkForAbsence?: boolean;
        grayscaleRange?: PresenceAbsence.GrayscaleRange;
        greenRange?: PresenceAbsence.GreenRange;
        hueRange?: PresenceAbsence.HueRange;
        redRange?: PresenceAbsence.RedRange;
        saturationRange?: PresenceAbsence.SaturationRange;
        score?: number;
        threshold?: number;
        valueRange?: PresenceAbsence.ValueRange;
    }

    export namespace PresenceAbsence {
        export interface BlueRange {
            high?: number;
            low?: number;
        }

        export interface GrayscaleRange {
            high?: number;
            low?: number;
        }

        export interface GreenRange {
            high?: number;
            low?: number;
        }

        export interface HueRange {
            high?: number;
            low?: number;
        }

        export interface RedRange {
            high?: number;
            low?: number;
        }

        export interface SaturationRange {
            high?: number;
            low?: number;
        }

        export interface ValueRange {
            high?: number;
            low?: number;
        }
    }

    export interface TextMatch {
        foundText?: string;
        matchString?: string;
    }
}
