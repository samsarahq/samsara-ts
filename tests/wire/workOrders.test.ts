// This file was auto-generated by Fern from our API Definition.

import * as Samsara from "../../src/api/index";
import { SamsaraClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("WorkOrdersClient", () => {
    test("postInvoiceScan (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = {
            file: { base64Content: "JVBERi0xLjQKJeLjz9MKMyAwIG9iago8P...", contentType: "application/pdf" },
        };
        const rawResponseBody = { data: { workOrderId: "123456" } };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workOrders.postInvoiceScan({
            file: {
                base64Content: "JVBERi0xLjQKJeLjz9MKMyAwIG9iago8P...",
                contentType: "application/pdf",
            },
        });
        expect(response).toEqual({
            data: {
                workOrderId: "123456",
            },
        });
    });

    test("postInvoiceScan (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("postInvoiceScan (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("postInvoiceScan (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("postInvoiceScan (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("postInvoiceScan (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("postInvoiceScan (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("postInvoiceScan (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("postInvoiceScan (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("postInvoiceScan (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { file: { base64Content: "base64Content", contentType: "contentType" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/invoice-scans")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postInvoiceScan({
                file: {
                    base64Content: "base64Content",
                    contentType: "contentType",
                },
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getServiceTasks (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    category: "Engine",
                    description: "Standard oil change service including filter replacement.",
                    estimatedLaborTimeMinutes: 30,
                    estimatedPartsCost: { amount: "94.01", currency: "usd" },
                    id: "abf63a9a-4d75-423d-b49f-38a071e6ce36",
                    name: "Oil Change",
                    subcategory: "Oil and Lubrication",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workOrders.getServiceTasks();
        expect(response).toEqual({
            data: [
                {
                    category: "Engine",
                    description: "Standard oil change service including filter replacement.",
                    estimatedLaborTimeMinutes: 30,
                    estimatedPartsCost: {
                        amount: "94.01",
                        currency: "usd",
                    },
                    id: "abf63a9a-4d75-423d-b49f-38a071e6ce36",
                    name: "Oil Change",
                    subcategory: "Oil and Lubrication",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getServiceTasks (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getServiceTasks (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getServiceTasks (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getServiceTasks (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getServiceTasks (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getServiceTasks (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getServiceTasks (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getServiceTasks (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getServiceTasks (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/service-tasks")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getServiceTasks();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("getWorkOrders (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    archivedAtTime: "2019-06-13T19:08:25Z",
                    assetId: "12443",
                    assignedUserId: "1234",
                    attachments: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            processingStatus: "unknown",
                            url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                            urlExpiresAt: "2019-06-13T19:08:25Z",
                        },
                    ],
                    category: "PREVENTIVE",
                    closingNotes: "Everything was fixed without issues.",
                    completedAtTime: "2019-06-13T19:08:25Z",
                    createdAtTime: "2019-06-13T19:08:25Z",
                    createdByUserId: "1234",
                    description: "The vehicle is not starting.",
                    discount: { basisPoints: 500, money: { amount: "94.01", currency: "usd" } },
                    dueAtTime: "2019-06-13T19:08:25Z",
                    engineHours: 91823,
                    id: "5",
                    invoiceNumber: "123456",
                    items: [{ id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7", type: "DVIR" }],
                    odometerMeters: 91823,
                    poNumber: "123456",
                    priority: "High",
                    serviceTaskInstances: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            laborHourlyCost: { amount: "94.01", currency: "usd" },
                            laborTimeMinutes: 60,
                            parts: [
                                {
                                    costCentsOverride: 1000,
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    partId: "P0077",
                                    quantity: 2.5,
                                },
                            ],
                            partsCost: { amount: "94.01", currency: "usd" },
                            serviceTaskId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            status: "Unknown",
                        },
                    ],
                    status: "Assigned",
                    tax: { basisPoints: 700, money: { amount: "94.01", currency: "usd" } },
                    updatedAtTime: "2019-06-13T19:08:25Z",
                    vendorUuid: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workOrders.getWorkOrders();
        expect(response).toEqual({
            data: [
                {
                    archivedAtTime: "2019-06-13T19:08:25Z",
                    assetId: "12443",
                    assignedUserId: "1234",
                    attachments: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            processingStatus: "unknown",
                            url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                            urlExpiresAt: "2019-06-13T19:08:25Z",
                        },
                    ],
                    category: "PREVENTIVE",
                    closingNotes: "Everything was fixed without issues.",
                    completedAtTime: "2019-06-13T19:08:25Z",
                    createdAtTime: "2019-06-13T19:08:25Z",
                    createdByUserId: "1234",
                    description: "The vehicle is not starting.",
                    discount: {
                        basisPoints: 500,
                        money: {
                            amount: "94.01",
                            currency: "usd",
                        },
                    },
                    dueAtTime: "2019-06-13T19:08:25Z",
                    engineHours: 91823,
                    id: "5",
                    invoiceNumber: "123456",
                    items: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            type: "DVIR",
                        },
                    ],
                    odometerMeters: 91823,
                    poNumber: "123456",
                    priority: "High",
                    serviceTaskInstances: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            laborHourlyCost: {
                                amount: "94.01",
                                currency: "usd",
                            },
                            laborTimeMinutes: 60,
                            parts: [
                                {
                                    costCentsOverride: 1000,
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    partId: "P0077",
                                    quantity: 2.5,
                                },
                            ],
                            partsCost: {
                                amount: "94.01",
                                currency: "usd",
                            },
                            serviceTaskId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            status: "Unknown",
                        },
                    ],
                    status: "Assigned",
                    tax: {
                        basisPoints: 700,
                        money: {
                            amount: "94.01",
                            currency: "usd",
                        },
                    },
                    updatedAtTime: "2019-06-13T19:08:25Z",
                    vendorUuid: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("getWorkOrders (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("getWorkOrders (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("getWorkOrders (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("getWorkOrders (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("getWorkOrders (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("getWorkOrders (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("getWorkOrders (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("getWorkOrders (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("getWorkOrders (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.getWorkOrders();
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("postWorkOrders (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "12443" };
        const rawResponseBody = {
            data: {
                archivedAtTime: "2019-06-13T19:08:25Z",
                assetId: "12443",
                assignedUserId: "1234",
                attachments: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        processingStatus: "unknown",
                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                        urlExpiresAt: "2019-06-13T19:08:25Z",
                    },
                ],
                category: "PREVENTIVE",
                closingNotes: "Everything was fixed without issues.",
                completedAtTime: "2019-06-13T19:08:25Z",
                createdAtTime: "2019-06-13T19:08:25Z",
                createdByUserId: "1234",
                description: "The vehicle is not starting.",
                discount: { basisPoints: 500, money: { amount: "94.01", currency: "usd" } },
                dueAtTime: "2019-06-13T19:08:25Z",
                engineHours: 91823,
                id: "5",
                invoiceNumber: "123456",
                items: [{ id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7", type: "DVIR" }],
                odometerMeters: 91823,
                poNumber: "123456",
                priority: "High",
                serviceTaskInstances: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        laborHourlyCost: { amount: "94.01", currency: "usd" },
                        laborTimeMinutes: 60,
                        parts: [
                            {
                                costCentsOverride: 1000,
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                partId: "P0077",
                                quantity: 2.5,
                            },
                        ],
                        partsCost: { amount: "94.01", currency: "usd" },
                        serviceTaskId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        status: "Unknown",
                    },
                ],
                status: "Assigned",
                tax: { basisPoints: 700, money: { amount: "94.01", currency: "usd" } },
                updatedAtTime: "2019-06-13T19:08:25Z",
                vendorUuid: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
            },
        };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workOrders.postWorkOrders({
            assetId: "12443",
        });
        expect(response).toEqual({
            data: {
                archivedAtTime: "2019-06-13T19:08:25Z",
                assetId: "12443",
                assignedUserId: "1234",
                attachments: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        processingStatus: "unknown",
                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                        urlExpiresAt: "2019-06-13T19:08:25Z",
                    },
                ],
                category: "PREVENTIVE",
                closingNotes: "Everything was fixed without issues.",
                completedAtTime: "2019-06-13T19:08:25Z",
                createdAtTime: "2019-06-13T19:08:25Z",
                createdByUserId: "1234",
                description: "The vehicle is not starting.",
                discount: {
                    basisPoints: 500,
                    money: {
                        amount: "94.01",
                        currency: "usd",
                    },
                },
                dueAtTime: "2019-06-13T19:08:25Z",
                engineHours: 91823,
                id: "5",
                invoiceNumber: "123456",
                items: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        type: "DVIR",
                    },
                ],
                odometerMeters: 91823,
                poNumber: "123456",
                priority: "High",
                serviceTaskInstances: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        laborHourlyCost: {
                            amount: "94.01",
                            currency: "usd",
                        },
                        laborTimeMinutes: 60,
                        parts: [
                            {
                                costCentsOverride: 1000,
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                partId: "P0077",
                                quantity: 2.5,
                            },
                        ],
                        partsCost: {
                            amount: "94.01",
                            currency: "usd",
                        },
                        serviceTaskId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        status: "Unknown",
                    },
                ],
                status: "Assigned",
                tax: {
                    basisPoints: 700,
                    money: {
                        amount: "94.01",
                        currency: "usd",
                    },
                },
                updatedAtTime: "2019-06-13T19:08:25Z",
                vendorUuid: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
            },
        });
    });

    test("postWorkOrders (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("postWorkOrders (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("postWorkOrders (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("postWorkOrders (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("postWorkOrders (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("postWorkOrders (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("postWorkOrders (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("postWorkOrders (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("postWorkOrders (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { assetId: "assetId" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.postWorkOrders({
                assetId: "assetId",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("deleteWorkOrders (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        server.mockEndpoint().delete("/maintenance/work-orders").respondWith().statusCode(200).build();

        const response = await client.workOrders.deleteWorkOrders({
            id: "id",
        });
        expect(response).toEqual(undefined);
    });

    test("deleteWorkOrders (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("deleteWorkOrders (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("deleteWorkOrders (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("deleteWorkOrders (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("deleteWorkOrders (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("deleteWorkOrders (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("deleteWorkOrders (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("deleteWorkOrders (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("deleteWorkOrders (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/maintenance/work-orders")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.deleteWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("patchWorkOrders (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "5" };
        const rawResponseBody = {
            data: {
                archivedAtTime: "2019-06-13T19:08:25Z",
                assetId: "12443",
                assignedUserId: "1234",
                attachments: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        processingStatus: "unknown",
                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                        urlExpiresAt: "2019-06-13T19:08:25Z",
                    },
                ],
                category: "PREVENTIVE",
                closingNotes: "Everything was fixed without issues.",
                completedAtTime: "2019-06-13T19:08:25Z",
                createdAtTime: "2019-06-13T19:08:25Z",
                createdByUserId: "1234",
                description: "The vehicle is not starting.",
                discount: { basisPoints: 500, money: { amount: "94.01", currency: "usd" } },
                dueAtTime: "2019-06-13T19:08:25Z",
                engineHours: 91823,
                id: "5",
                invoiceNumber: "123456",
                items: [{ id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7", type: "DVIR" }],
                odometerMeters: 91823,
                poNumber: "123456",
                priority: "High",
                serviceTaskInstances: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        laborHourlyCost: { amount: "94.01", currency: "usd" },
                        laborTimeMinutes: 60,
                        parts: [
                            {
                                costCentsOverride: 1000,
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                partId: "P0077",
                                quantity: 2.5,
                            },
                        ],
                        partsCost: { amount: "94.01", currency: "usd" },
                        serviceTaskId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        status: "Unknown",
                    },
                ],
                status: "Assigned",
                tax: { basisPoints: 700, money: { amount: "94.01", currency: "usd" } },
                updatedAtTime: "2019-06-13T19:08:25Z",
                vendorUuid: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
            },
        };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workOrders.patchWorkOrders({
            id: "5",
        });
        expect(response).toEqual({
            data: {
                archivedAtTime: "2019-06-13T19:08:25Z",
                assetId: "12443",
                assignedUserId: "1234",
                attachments: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        processingStatus: "unknown",
                        url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                        urlExpiresAt: "2019-06-13T19:08:25Z",
                    },
                ],
                category: "PREVENTIVE",
                closingNotes: "Everything was fixed without issues.",
                completedAtTime: "2019-06-13T19:08:25Z",
                createdAtTime: "2019-06-13T19:08:25Z",
                createdByUserId: "1234",
                description: "The vehicle is not starting.",
                discount: {
                    basisPoints: 500,
                    money: {
                        amount: "94.01",
                        currency: "usd",
                    },
                },
                dueAtTime: "2019-06-13T19:08:25Z",
                engineHours: 91823,
                id: "5",
                invoiceNumber: "123456",
                items: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        type: "DVIR",
                    },
                ],
                odometerMeters: 91823,
                poNumber: "123456",
                priority: "High",
                serviceTaskInstances: [
                    {
                        id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        laborHourlyCost: {
                            amount: "94.01",
                            currency: "usd",
                        },
                        laborTimeMinutes: 60,
                        parts: [
                            {
                                costCentsOverride: 1000,
                                id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                partId: "P0077",
                                quantity: 2.5,
                            },
                        ],
                        partsCost: {
                            amount: "94.01",
                            currency: "usd",
                        },
                        serviceTaskId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                        status: "Unknown",
                    },
                ],
                status: "Assigned",
                tax: {
                    basisPoints: 700,
                    money: {
                        amount: "94.01",
                        currency: "usd",
                    },
                },
                updatedAtTime: "2019-06-13T19:08:25Z",
                vendorUuid: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
            },
        });
    });

    test("patchWorkOrders (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("patchWorkOrders (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("patchWorkOrders (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("patchWorkOrders (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("patchWorkOrders (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("patchWorkOrders (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("patchWorkOrders (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("patchWorkOrders (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("patchWorkOrders (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/maintenance/work-orders")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.patchWorkOrders({
                id: "id",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });

    test("streamWorkOrders (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = {
            data: [
                {
                    archivedAtTime: "2019-06-13T19:08:25Z",
                    assetId: "12443",
                    assignedUserId: "1234",
                    attachments: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            processingStatus: "unknown",
                            url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                            urlExpiresAt: "2019-06-13T19:08:25Z",
                        },
                    ],
                    category: "PREVENTIVE",
                    closingNotes: "Everything was fixed without issues.",
                    completedAtTime: "2019-06-13T19:08:25Z",
                    createdAtTime: "2019-06-13T19:08:25Z",
                    createdByUserId: "1234",
                    description: "The vehicle is not starting.",
                    discount: { basisPoints: 500, money: { amount: "94.01", currency: "usd" } },
                    dueAtTime: "2019-06-13T19:08:25Z",
                    engineHours: 91823,
                    id: "5",
                    invoiceNumber: "123456",
                    items: [{ id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7", type: "DVIR" }],
                    odometerMeters: 91823,
                    poNumber: "123456",
                    priority: "High",
                    serviceTaskInstances: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            laborHourlyCost: { amount: "94.01", currency: "usd" },
                            laborTimeMinutes: 60,
                            parts: [
                                {
                                    costCentsOverride: 1000,
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    partId: "P0077",
                                    quantity: 2.5,
                                },
                            ],
                            partsCost: { amount: "94.01", currency: "usd" },
                            serviceTaskId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            status: "Unknown",
                        },
                    ],
                    status: "Assigned",
                    tax: { basisPoints: 700, money: { amount: "94.01", currency: "usd" } },
                    updatedAtTime: "2019-06-13T19:08:25Z",
                    vendorUuid: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
                },
            ],
            pagination: { endCursor: "MjkY", hasNextPage: true },
        };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.workOrders.streamWorkOrders({
            startTime: "startTime",
        });
        expect(response).toEqual({
            data: [
                {
                    archivedAtTime: "2019-06-13T19:08:25Z",
                    assetId: "12443",
                    assignedUserId: "1234",
                    attachments: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            processingStatus: "unknown",
                            url: "https://samsara-forms-submission-media-uploads.s3.us-west-2.amazonaws.com/123456",
                            urlExpiresAt: "2019-06-13T19:08:25Z",
                        },
                    ],
                    category: "PREVENTIVE",
                    closingNotes: "Everything was fixed without issues.",
                    completedAtTime: "2019-06-13T19:08:25Z",
                    createdAtTime: "2019-06-13T19:08:25Z",
                    createdByUserId: "1234",
                    description: "The vehicle is not starting.",
                    discount: {
                        basisPoints: 500,
                        money: {
                            amount: "94.01",
                            currency: "usd",
                        },
                    },
                    dueAtTime: "2019-06-13T19:08:25Z",
                    engineHours: 91823,
                    id: "5",
                    invoiceNumber: "123456",
                    items: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            type: "DVIR",
                        },
                    ],
                    odometerMeters: 91823,
                    poNumber: "123456",
                    priority: "High",
                    serviceTaskInstances: [
                        {
                            id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            laborHourlyCost: {
                                amount: "94.01",
                                currency: "usd",
                            },
                            laborTimeMinutes: 60,
                            parts: [
                                {
                                    costCentsOverride: 1000,
                                    id: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                                    partId: "P0077",
                                    quantity: 2.5,
                                },
                            ],
                            partsCost: {
                                amount: "94.01",
                                currency: "usd",
                            },
                            serviceTaskId: "9814a1fa-f0c6-408b-bf85-51dc3bc71ac7",
                            status: "Unknown",
                        },
                    ],
                    status: "Assigned",
                    tax: {
                        basisPoints: 700,
                        money: {
                            amount: "94.01",
                            currency: "usd",
                        },
                    },
                    updatedAtTime: "2019-06-13T19:08:25Z",
                    vendorUuid: "5523a39f-42ef-4820-83d0-dfe73dbe7853",
                },
            ],
            pagination: {
                endCursor: "MjkY",
                hasNextPage: true,
            },
        });
    });

    test("streamWorkOrders (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.UnauthorizedError);
    });

    test("streamWorkOrders (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotFoundError);
    });

    test("streamWorkOrders (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(405)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.MethodNotAllowedError);
    });

    test("streamWorkOrders (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.TooManyRequestsError);
    });

    test("streamWorkOrders (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.InternalServerError);
    });

    test("streamWorkOrders (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.NotImplementedError);
    });

    test("streamWorkOrders (8)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(502)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.BadGatewayError);
    });

    test("streamWorkOrders (9)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.ServiceUnavailableError);
    });

    test("streamWorkOrders (10)", async () => {
        const server = mockServerPool.createServer();
        const client = new SamsaraClient({
            maxRetries: 0,
            token: "test",
            version: "2025-06-11",
            environment: server.baseUrl,
        });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/maintenance/work-orders/stream")
            .respondWith()
            .statusCode(504)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.workOrders.streamWorkOrders({
                startTime: "startTime",
            });
        }).rejects.toThrow(Samsara.GatewayTimeoutError);
    });
});
